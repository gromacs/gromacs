/*
 * This file is part of the GROMACS molecular simulation package.
 *
 * Copyright (c) 2015, by the GROMACS development team, led by
 * Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,
 * and including many others, as listed in the AUTHORS file in the
 * top-level source directory and at http://www.gromacs.org.
 *
 * GROMACS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * GROMACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with GROMACS; if not, see
 * http://www.gnu.org/licenses, or write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.
 *
 * If you want to redistribute modifications to GROMACS, please
 * consider that scientific software is very special. Version
 * control is crucial - bugs must be traceable. We will be happy to
 * consider code for inclusion in the official distribution, but
 * derived work must not be called official GROMACS. Details are found
 * in the README & COPYING files - if they are missing, get the
 * official version at http://www.gromacs.org.
 *
 * To help us fund GROMACS development, we humbly ask that you cite
 * the research papers on the package. Check out http://www.gromacs.org.
 */

/*! \file
 * \brief Random number utility functions for GROMACS
 *
 * Random number utilities compatible with C++11, but more optimized
 * for usage in molecular simulation applications.
 * Since the results from the C++ standard library random distributions will
 * depend on the implementation, we provide our own portable versions that
 * generate the same result on all platforms.
 *
 * \author Erik Lindahl <erik.lindahl@gmail.com>
 * \inpublicapi
 * \ingroup module_math
 */

#ifndef GMX_MATH_RANDOM_H
#define GMX_MATH_RANDOM_H

#include <cmath>

#include <algorithm>
#include <array>
#include <limits>
#include <random>

#include "gromacs/math/utilities.h"
#include "gromacs/utility/basedefinitions.h"
#include "gromacs/utility/classhelpers.h"
#include "gromacs/utility/exceptions.h"
#include "gromacs/utility/gmxassert.h"

/*
 * The GROMACS implementation of the ThreeFry random engine has been
 * heavily inspired by the versions proposed to Boost by:
 *
 * John Salmon, Copyright 2010-2014 by D. E. Shaw Research
 * https://github.com/DEShawResearch/Random123-Boost
 *
 * Thijs van den Berg, Copyright (c) 2014 M.A. (Thijs) van den Berg
 * https://github.com/sitmo/threefry
 *
 * Both of them are covered by the Boost Software License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */


/*
 * The workaround implementation for the broken std::gamma_distribution in the
 * gcc-4.6 headers, and our portable versions of the other distributions
 * (to make sure we get the same values on all platforms) have been modified
 * from the LLVM libcxx headers, distributed under the MIT license:
 *
 * Copyright (c) The LLVM compiler infrastructure
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

namespace gmx
{

/*! \brief Return 64 random bits from the random device, suitable as seed.
 *
 *  If the internal random device output is smaller than 64 bits, this routine
 *  will use multiple calls internally until we have 64 bits of random data.
 *
 *  \return 64-bit unsigned integer with random bits.
 */
gmx_uint64_t
makeRandomSeed();

/*! \brief Enumerated values for fixed part of random seed (domain)
 *
 *  Random numbers are used in many places in GROMACS, and to avoid identical
 *  streams the random seeds should be different. Instead of keeping track of
 *  several different user-provided seeds, it is better to use the fact that
 *  ThreeFry takes two 64-bit keys, and combine a general user-provided 64-bit
 *  random seed with a second constant value from this list to make each stream
 *  guaranteed unique.
 *
 *  \note There is no reason to go overboard with adding options; we only
 *        need to guarantee different streams for cases that might be present
 *        simultaneously in a single simulation. As an example, two different
 *        integrators (or thermostats) can reuse the same domain.
 *  \note When you do add options, leave some space between the values so
 *        you can group new options with old ones without changing old values.
 */
enum class RandomDomain
{
    Other                    = 0x00000000,   //!< Generic - stream uniqueness is not important
    MaxwellVelocities        = 0x00001000,   //!< Veolcity assignment from Maxwell distribution
    TestParticleInsertion    = 0x00002000,   //!< Test particle insertion
    UpdateCoordinates        = 0x00003000,   //!< Particle integrators
    UpdateConstraints        = 0x00004000,   //!< Second integrator step for constraints
    Thermostat               = 0x00005000,   //!< Stochastic temperature coupling
    Barostat                 = 0x00006000,   //!< Stochastic pressure coupling
    ReplicaExchange          = 0x00007000,   //!< Replica exchange metropolis moves
    ExpandedEnsemble         = 0x00008000    //!< Expanded ensemble lambda moves
};


namespace internal
{
// Variable-bitfield counters used to increment internal counters as
// part of std::arrays.

struct
highBitCounter
{
    /*! \brief Clear highBits higest bits of ctr, return false if they were non-zero.
     *
     *  This function clears the space required for the internal counters,
     *  and returns true if they were correctly zero when calling, false otherwise.
     *
     *  \tparam        UIntType  Integer type to use for each word in counter
     *  \tparam        words     Number of UIntType words in counter
     *  \tparam        highBits  Number of bits to check. The template parameter makes it
     *                           possible to optimize this extensively at compile time.
     *  \param         ctr       Reference to counter to check and clear.
     */
    template<class UIntType, std::size_t words, unsigned int highBits>
    static bool
    checkAndClear(std::array<UIntType, words> * ctr)
    {
        const std::size_t  bitsPerWord       = std::numeric_limits<UIntType>::digits;
        const std::size_t  bitsTotal         = bitsPerWord*words;

        static_assert(highBits <= bitsTotal, "High bits do not fit in counter.");

        const std::size_t  lastWordIdx       = (bitsTotal - highBits) / bitsPerWord;
        const std::size_t  lastWordLowBitIdx = (bitsTotal - highBits) % bitsPerWord;
        const UIntType     lastWordOne       = static_cast<UIntType>(1) << lastWordLowBitIdx;
        const UIntType     mask              = lastWordOne-1;

        bool               isClear              = true;

        for (unsigned int i = words-1; i > lastWordIdx; --i)
        {
            if ((*ctr)[i])
            {
                isClear    = false;
                (*ctr)[i]  = 0;
            }
        }
        if (highBits > 0 && (*ctr)[lastWordIdx] >= lastWordOne)
        {
            isClear                 = false;
            (*ctr)[lastWordIdx]    &= mask;
        }
        return isClear;
    }

    /*! \brief Increment the internal counter in highBits by one
     *
     *  \tparam         UIntType  Integer type to use for each word in counter
     *  \tparam         words     Number of UIntType words in counter
     *  \tparam         highBits  Number of bits reserved for the internal counter.
     *  \param          ctr       Reference to the counter value to increment.
     *
     *  \throws InternalError if internal counter space is exhausted.
     *
     *  This routine will work across the word boundaries for any number
     *  of internal counter bits that fits in the total counter.
     */
    template<class UIntType, std::size_t words, unsigned int highBits>
    static void
    increment(std::array<UIntType, words> * ctr)
    {
        const std::size_t  bitsPerWord       = std::numeric_limits<UIntType>::digits;
        const std::size_t  bitsTotal         = bitsPerWord*words;

        static_assert(highBits <= bitsTotal, "High bits do not fit in counter.");

        const std::size_t  lastWordIdx       = (bitsTotal - highBits) / bitsPerWord;
        const std::size_t  lastWordLowBitIdx = (bitsTotal - highBits) % bitsPerWord;
        const UIntType     lastWordOne       = static_cast<UIntType>(1) << lastWordLowBitIdx;

        // For algorithm & efficiency reasons we need to store the internal counter in
        // the same array as the user-provided counter, so we use the higest bits, possibly
        // crossing several words.
        //
        // To have the computer help us with the dirty carry arithmetics we store the bits
        // in the internal counter part in normal fashion, but the internal counter words in
        // reverse order; the highest word of the total counter array (words-1) is thus
        // the least significant part of the internal counter (if it spans several words).
        //
        // The incrementation works as follows:
        //
        // 0) If the index of the least significant internal counter word is larger
        //    than words-1, there was never any space.
        // 1) If the internal counter spans more than one word, we must have one or
        //    more internal counter words that correspond entirely to the this counter.
        //    Start with the least significant one (words-1) and increment it.
        //    If the new value is not zero we did not loop around (no carry), so everything
        //    is good, and we are done - return!
        //    If the new value is zero, we need to move the carry result to the next word,
        //    so we just continue the loop until we have gone through all words that
        //    are internal-counter-only.
        // 2) After the loop, there is stuff remaining to add, and by definition there
        //    is some internal counter space in the next word, but the question
        //    is if we have exhausted it. We already created a constant that corresponds
        //    to the bit that represents '1' for the internal counter part of this word.
        //    When we add this constant it will not affect the user-counter-part at all,
        //    and if we exhaust the internal counter space the high bits will cause the entire
        //    word to wrap around, and the result will be smaller than the bit we added.
        //    If this happens we throw, otherwise we're done.
        //
        // Since all constants will be evaluated at compile time, this entire routine
        // will usually be reduced to simply incrementing a word by a constant, and throwing
        // if the result is smaller than the constant.

        if (lastWordIdx >= words)
        {
            GMX_THROW(InternalError("Cannot increment random engine defined with 0 internal counter bits."));
        }

        for (unsigned int i = words-1; i > lastWordIdx; --i)
        {
            (*ctr)[i]++;
            if ((*ctr)[i])
            {
                return;     // No carry means we are done
            }
        }
        (*ctr)[lastWordIdx] += lastWordOne;
        if ((*ctr)[lastWordIdx] < lastWordOne)
        {
            GMX_THROW(InternalError("Random engine stream ran out of internal counter space."));
        }
        return;
    }

    /*! \brief Increment the internal counter in highBits by a value.
     *
     *  \tparam        UIntType  Integer type to use for each word in counter
     *  \tparam        words     Number of UIntType words in counter
     *  \tparam        highBits  Number of bits reserved for the internal counter.
     *  \param         ctr       Reference to the counter to increment.
     *  \param         addend    Value to add to internal.
     *
     *  \throws InternalError if internal counter space is exhausted.
     *
     *  This routine will work across the word boundaries for any number
     *  of internal counter bits that fits in the total counter.
     */
    template<class UIntType, std::size_t words, unsigned int highBits>
    static void
    increment(std::array<UIntType, words> * ctr, UIntType addend)
    {
        const std::size_t  bitsPerWord       = std::numeric_limits<UIntType>::digits;
        const std::size_t  bitsTotal         = bitsPerWord*words;

        static_assert(highBits <= bitsTotal, "High bits do not fit in counter.");

        const std::size_t  lastWordIdx       = (bitsTotal - highBits) / bitsPerWord;
        const std::size_t  lastWordLowBitIdx = (bitsTotal - highBits) % bitsPerWord;
        const UIntType     lastWordOne       = static_cast<UIntType>(1) << lastWordLowBitIdx;
        const UIntType     lastWordMaxVal    = (~static_cast<UIntType>(0)) >> lastWordLowBitIdx;

        if (lastWordIdx >= words)
        {
            GMX_THROW(InternalError("Cannot increment random engine defined with 0 internal counter bits."));
        }

        for (unsigned int i = words-1; i > lastWordIdx; --i)
        {
            (*ctr)[i] += addend;
            addend     = ((*ctr)[i] < addend);   // 1 is the carry!
            if (addend == 0)
            {
                return;
            }
        }

        if (addend > lastWordMaxVal)
        {
            GMX_THROW(InternalError("Random engine stream ran out of internal counter space."));
        }
        addend *= lastWordOne;

        (*ctr)[lastWordIdx] += addend;

        if ((*ctr)[lastWordIdx] < addend)
        {
            GMX_THROW(InternalError("Random engine stream ran out of internal counter space."));
        }
        return;
    }
};
}

/*! \brief General implementation class for ThreeFry counter-based random engines.
 *
 *  This class is used to implement several different ThreeFry2x64 random engines
 *  differing in the number of rounds executed in and the number of bits reserved
 *  for the internal counter. It is compatible with C++11 random engines, and
 *  can be used e.g. with all random distributions from the standard library.
 *
 *  ThreeFry is a counter-based rather than state-based random engine. This
 *  means that we seed it with a "key", after which we can get the
 *  N:th random number in a sequence (specified by a counter) directly. This
 *  means we are guaranteed the same sequence of numbers even when running in
 *  parallel if using e.g. step and atom index as counters.
 *
 *  However, it is also useful to be able to use it as a normal random engine,
 *  for instance if you need more than 2 64-bit random values for a specific
 *  counter value, not to mention where you just need good normal random numbers.
 *  To achieve this, this implementation uses John Salmon's idea of reserving
 *  a couple of the highest bits in the user-provided counter for an internal
 *  counter. For instance, if reserving 3 bits, this means you get a stream of
 *  8 iterations (each with 2 random values) after every restart. If you call
 *  the engine after these bits have been exhausted, it will throw an
 *  exception to make sure you don't get overlapping streams by mistake.
 *  Reserving 3 bits also means you can only use 64-3=61 bits of the highest
 *  word when restarting (i.e., setting) the counters.
 *
 *  This version also supports using internalCounterBits=0. In this case the
 *  random engine will be able to return a single counter round, i.e. 2 64-bit
 *  values for ThreeFry2x64, after which an exception is thrown. In this case no
 *  high bits are reserved, which means the class implements the raw ThreeFry2x64
 *  random function.
 *
 *  \tparam rounds  The number of encryption iterations used when generating.
 *                  This can in principle be any value, but 20 rounds has been
 *                  shown to pass all BigCrush random tests, and with 13 rounds
 *                  only one fails. This is a very stringent test, and the
 *                  standard Mersenne Twister engine fails two, so 13 rounds
 *                  should be a perfectly fine balance in most cases.
 *  \tparam internalCounterBits
 *                  Number of high bits in the user-provided counter reserved
 *                  for the internal counter. The number of values the engine
 *                  can return after each restart will be
 *                  words*2^internalCounterBits.
 */
template<unsigned int rounds, unsigned int internalCounterBits>
class ThreeFry2x64General
{
    // While this class will formally work with any value for rounds, there is
    // no reason to go lower than 13, and this might help catch some typos.
    // If we find a reason to use lower values in the future, or if you simply
    // want to test, this assert can safely be removed.
    static_assert(rounds >= 13, "You should not use less than 13 encryption rounds for ThreeFry2x64.");

    public:
        // result_type must be lower case to be compatible with C++11 standard library

        /*! \brief Integer type for output. */
        typedef gmx_uint64_t                    result_type;
        /*! \brief Use array for counter & key states so it is allocated on the stack */
        typedef std::array<result_type, 2>      counter_type;

    private:

        /*! \brief Rotate value left by specified number of bits
         *
         *  \param i    Value to rotate (result_type, which should be 64-bit).
         *  \param bits Number of bits to rotate i.
         *
         *  \return Input value rotated 'bits' left.
         */
        result_type
        rotLeft(result_type i, unsigned int bits)
        {
            return (i << bits) | (i >> (std::numeric_limits<result_type>::digits-bits));
        }

        /*! \brief Perform encryption step for ThreeFry2x64 algorithm
         *
         *  It performs the encryption step of the standard ThreeFish symmetric-key
         *  tweakable block cipher, which is the core of the ThreeFry random
         *  engine. The number of encryption rounds is specified by the class
         *  template parameter 'rounds'.
         *
         *  \param key   Reference to key value
         *  \param ctr   Counter value to use
         *
         *  \return Newly encrypted 2x64 block, according to the class template parameters.
         */
        counter_type
        generateBlock(const counter_type &key,
                      const counter_type &ctr)
        {
            const unsigned int  rotations[] = {16, 42, 12, 31, 16, 32, 24, 21};
            counter_type        x           = ctr;

            result_type         ks[3];

            ks[2] = 0x1bd11bdaa9fc1a22;

            // This is actually a pretty simple routine that merely executes the
            // for-block specified further down 'rounds' times. However, both
            // clang and gcc have problems unrolling and replacing rotations[r%8]
            // with constants, so we unroll the first 20 iterations manually.

            if (rounds > 0)
            {
                ks[0] = key[0]; ks[2] ^= key[0]; x[0] = x[0] + key[0];
                ks[1] = key[1]; ks[2] ^= key[1]; x[1] = x[1] + key[1];
                x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0];
            }
            if (rounds > 1)  { x[0] += x[1]; x[1] = rotLeft(x[1], 42); x[1] ^= x[0]; }
            if (rounds > 2)  { x[0] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[0]; }
            if (rounds > 3)  { x[0] += x[1]; x[1] = rotLeft(x[1], 31); x[1] ^= x[0]; x[0] += ks[1]; x[1] += ks[2] + 1; }
            if (rounds > 4)  { x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0]; }
            if (rounds > 5)  { x[0] += x[1]; x[1] = rotLeft(x[1], 32); x[1] ^= x[0]; }
            if (rounds > 6)  { x[0] += x[1]; x[1] = rotLeft(x[1], 24); x[1] ^= x[0]; }
            if (rounds > 7)  { x[0] += x[1]; x[1] = rotLeft(x[1], 21); x[1] ^= x[0]; x[0] += ks[2]; x[1] += ks[0] + 2; }
            if (rounds > 8)  { x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0]; }
            if (rounds > 9)  { x[0] += x[1]; x[1] = rotLeft(x[1], 42); x[1] ^= x[0]; }
            if (rounds > 10) { x[0] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[0]; }
            if (rounds > 11) { x[0] += x[1]; x[1] = rotLeft(x[1], 31); x[1] ^= x[0]; x[0] += ks[0]; x[1] += ks[1] + 3; }
            if (rounds > 12) { x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0]; }
            if (rounds > 13) { x[0] += x[1]; x[1] = rotLeft(x[1], 32); x[1] ^= x[0]; }
            if (rounds > 14) { x[0] += x[1]; x[1] = rotLeft(x[1], 24); x[1] ^= x[0]; }
            if (rounds > 15) { x[0] += x[1]; x[1] = rotLeft(x[1], 21); x[1] ^= x[0]; x[0] += ks[1]; x[1] += ks[2] + 4; }
            if (rounds > 16) { x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0]; }
            if (rounds > 17) { x[0] += x[1]; x[1] = rotLeft(x[1], 42); x[1] ^= x[0]; }
            if (rounds > 18) { x[0] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[0]; }
            if (rounds > 19) { x[0] += x[1]; x[1] = rotLeft(x[1], 31); x[1] ^= x[0]; x[0] += ks[2]; x[1] += ks[0] + 5; }

            for (unsigned int r = 20; r < rounds; r++)
            {
                x[0] += x[1];
                x[1]  = rotLeft(x[1], rotations[r%8]);
                x[1] ^= x[0];
                if (( (r + 1) & 3 ) == 0)
                {
                    unsigned int r4 = (r + 1) >> 2;
                    x[0] += ks[ r4 % 3 ];
                    x[1] += ks[ (r4 + 1) % 3 ] + r4;
                }
            }
            return x;
        }

    public:
        //! \brief Smallest value that can be returned from random engine.
        static gmx_constexpr
        result_type min() { return std::numeric_limits<result_type>::min(); }

        //! \brief Largest value that can be returned from random engine.
        static gmx_constexpr
        result_type max() { return std::numeric_limits<result_type>::max(); }

        /*! \brief Construct random engine with 2x64 key values
         *
         *  This constructor takes two values, and should only be used with
         *  the 2x64 implementations.
         *
         *  \param key0   Random seed in the form of a 64-bit unsigned value.
         *  \param domain Random domain. This is used to guarantee that different
         *                applications of a random engine inside the code get different
         *                streams of random numbers, without requiring the user
         *                to provide lots of random seeds. Pick a value from the
         *                RandomDomain class, or RandomDomain::Other if it is
         *                not important. In the latter case you might want to use
         *                \ref gmx::DefaultRandomEngine instead.
         *
         *  \note The random domain is really another 64-bit seed value.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero.
         */
        ThreeFry2x64General(gmx_uint64_t key0 = 0, RandomDomain domain = RandomDomain::Other)
        {
            seed(key0, domain);
        }

        /*! \brief Construct random engine from 2x64-bit unsigned integers
         *
         *  This constructor assigns the raw 128 bit key data from unsigned integers.
         *  It is meant for the case when you want full control over the key,
         *  for instance to compare with reference values of the ThreeFry
         *  function during testing.
         *
         *  \param key0   First word of key/random seed.
         *  \param key1   Second word of key/random seed.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero. To test arbitrary values, use 0 internal counter bits.
         */
        ThreeFry2x64General(gmx_uint64_t key0, gmx_uint64_t key1)
        {
            seed(key0, key1);
        }

        /*! \brief Seed 2x64 random engine with two 64-bit key values
         *
         *  \param key0   First word of random seed, in the form of 64-bit unsigned values.
         *  \param domain Random domain. This is used to guarantee that different
         *                applications of a random engine inside the code get different
         *                streams of random numbers, without requiring the user
         *                to provide lots of random seeds. Pick a value from the
         *                RandomDomain class, or RandomDomain::Other if it is
         *                not important. In the latter case you might want to use
         *                \ref gmx::DefaultRandomEngine instead.
         *
         *  \note The random domain is really another 64-bit seed value.
         *
         *  Re-initialized the seed similar to the counter constructor.
         *  Same rules apply: The highest few bits of the last word are
         *  reserved to encode the number of internal counter bits, but
         *  to save the user the trouble of making sure these are zero
         *  when using e.g. a random device, we just ignore them.
         */
        void
        seed(gmx_uint64_t key0 = 0, RandomDomain domain = RandomDomain::Other)
        {
            seed(key0, static_cast<gmx_uint64_t>(domain));
        }

        /*! \brief Seed random engine from 2x64-bit unsigned integers
         *
         *  This assigns the raw 128 bit key data from unsigned integers.
         *  It is meant for the case when you want full control over the key,
         *  for instance to compare with reference values of the ThreeFry
         *  function during testing.
         *
         *  \param key0   First word of key/random seed.
         *  \param key1   Second word of key/random seed.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero. To test arbitrary values, use 0 internal counter bits.
         */
        void
        seed(gmx_uint64_t key0, gmx_uint64_t key1)
        {
            const unsigned int internalCounterBitsBits = (internalCounterBits > 0) ? ( StaticLog2<internalCounterBits>::value + 1 ) : 0;

            key_ = {{key0, key1}};

            if (internalCounterBits > 0)
            {
                internal::highBitCounter::checkAndClear<result_type, 2, internalCounterBitsBits>(&key_);
                internal::highBitCounter::increment<result_type, 2, internalCounterBitsBits>(&key_, internalCounterBits-1);
            }
            restart(0, 0);
        }

        /*! \brief Restart 2x64 random engine counter from 2 64-bit values
         *
         *  \param ctr0 First word of new counter, in the form of 64-bit unsigned values.
         *  \param ctr1 Second word of new counter
         *
         * Restarting the engine with a new counter is extremely fast with ThreeFry64,
         * and basically just consists of storing the counter value, so you should
         * use this liberally in your innermost loops to restart the engine with
         * e.g. the current step and atom index as counter values.
         *
         * \throws InternalError if any of the highest bits that are reserved
         *         for the internal part of the counter are set. The number of
         *         reserved bits is to the last template parameter to the class.
         */
        void
        restart(gmx_uint64_t ctr0 = 0, gmx_uint64_t ctr1 = 0)
        {

            counter_ = {{ctr0, ctr1}};
            if (!internal::highBitCounter::checkAndClear<result_type, 2, internalCounterBits>(&counter_))
            {
                GMX_THROW(InternalError("High bits of counter are reserved for the internal stream counter."));
            }
            block_ = generateBlock(key_, counter_);
            index_ = 0;
        }

        /*! \brief Generate the next random number
         *
         *  This will return the next stored 64-bit value if one is available,
         *  and otherwise generate a new block, update the internal counters, and
         *  return the first value while storing the others.
         *
         *  \throws InternalError if the internal counter space is exhausted.
         */
        result_type
        operator()()
        {
            if (index_ >= c_resultsPerCounter_)
            {
                internal::highBitCounter::increment<result_type, 2, internalCounterBits>(&counter_);
                block_ = generateBlock(key_, counter_);
                index_ = 0;
            }
            return block_[index_++];
        }

        /*! \brief Skip next n random numbers
         *
         *  Moves the internal random stream for the give key/counter value
         *  n positions forward. The count is based on the number of random values
         *  returned, such that skipping 5 values gives exactly the same result as
         *  drawing 5 values that are ignored.
         *
         *  \param n Number of values to jump forward.
         *
         *  \throws InternalError if the internal counter space is exhausted.
         */
        void
        discard(gmx_uint64_t n)
        {
            index_ += n % c_resultsPerCounter_;
            n      /= c_resultsPerCounter_;

            if (index_ > c_resultsPerCounter_)
            {
                index_ -= c_resultsPerCounter_;
                n++;
            }

            // Make sure the state is the same as if we came to this counter and
            // index by natural generation.
            if (index_ == 0 && n > 0)
            {
                index_ = c_resultsPerCounter_;
                n--;
            }
            internal::highBitCounter::increment<result_type, 2, internalCounterBits>(&counter_, n);
            block_ = generateBlock(key_, counter_);
        }

        /*! \brief Return true if two ThreeFry2x64 engines are identical
         *
         * \param  x    Instance to compare with.
         *
         * This routine should return true if the two engines will generate
         * identical random streams when drawing.
         */
        bool
        operator==(const ThreeFry2x64General<rounds, internalCounterBits> &x) const
        {
            // block_ is uniquely specified by key_ and counter_.
            return (key_ == x.key_ && counter_ == x.counter_ && index_ == x.index_);
        }

        /*! \brief Return true of two ThreeFry2x64 engines are not identical
         *
         * \param  x    Instance to compare with.
         *
         * This routine should return true if the two engines will generate
         * different random streams when drawing.
         */
        bool
        operator!=(const ThreeFry2x64General<rounds, internalCounterBits> &x) const { return !operator==(x); }

    private:

        /*! \brief Number of results returned for each invocation of the block generation */
        static const unsigned int c_resultsPerCounter_       = static_cast<unsigned int>(sizeof(counter_type)/sizeof(result_type));

        /*! \brief ThreeFry2x64 key, i.e. the random seed for this stream.
         *
         *  The highest few bits of the key are replaced to encode the value of
         *  internalCounterBits, in order to make all streams unique.
         */
        counter_type key_;

        /*! \brief ThreeFry2x64 total counter.
         *
         *  The highest internalCounterBits are reserved for an internal counter
         *  so that the combination of a key and counter provides a stream that
         *  returns 2*2^internalCounterBits (ThreeFry2x64) random 64-bit values before
         *  the internal counter space is exhausted and an exception is thrown.
         */
        counter_type counter_;
        /*! \brief The present block encrypted from values of key and counter. */
        counter_type block_;
        /*! \brief Index of the next value in block_ to return from random engine */
        unsigned int index_;

        GMX_DISALLOW_COPY_AND_ASSIGN(ThreeFry2x64General);
};


/*! \brief ThreeFry2x64 random engine with 20 iteractions.
 *
 *  \tparam internalCounterBits, default 64.
 *
 *  This class provides very high quality random numbers that pass all
 *  BigCrush tests, it works with two 64-bit values each for keys and
 *  counters, and is most  efficient when we only need a few random values
 *  before restarting the counters with new values.
 */
template<unsigned int internalCounterBits = 64>
class ThreeFry2x64 : public ThreeFry2x64General<20, internalCounterBits>
{
    public:
        /*! \brief Construct ThreeFry random engine with 2x64 key values, 20 rounds.
         *
         *  \param key0   Random seed in the form of a 64-bit unsigned value.
         *  \param domain Random domain. This is used to guarantee that different
         *                applications of a random engine inside the code get different
         *                streams of random numbers, without requiring the user
         *                to provide lots of random seeds. Pick a value from the
         *                RandomDomain class, or RandomDomain::Other if it is
         *                not important. In the latter case you might want to use
         *                \ref gmx::DefaultRandomEngine instead.
         *
         *  \note The random domain is really another 64-bit seed value.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero.
         */
        ThreeFry2x64(gmx_uint64_t key0 = 0, RandomDomain domain = RandomDomain::Other) : ThreeFry2x64General<20, internalCounterBits>(key0, domain) {}

        /*! \brief Construct random engine from 2x64-bit unsigned integers, 20 rounds
         *
         *  This constructor assigns the raw 128 bit key data from unsigned integers.
         *  It is meant for the case when you want full control over the key,
         *  for instance to compare with reference values of the ThreeFry
         *  function during testing.
         *
         *  \param key0   First word of key/random seed.
         *  \param key1   Second word of key/random seed.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero. To test arbitrary values, use 0 internal counter bits.
         */
        ThreeFry2x64(gmx_uint64_t key0, gmx_uint64_t key1) : ThreeFry2x64General<20, internalCounterBits>(key0, key1) {}
};

/*! \brief ThreeFry2x64 random engine with 13 iteractions.
 *
 *  \tparam internalCounterBits, default 64.
 *
 *  This class provides relatively high quality random numbers that only
 *  fail one BigCrush test, and it is a bit faster than the 20-round version.
 *  It works with two 64-bit values each for keys and counters, and is most
 *  efficient when we only need a few random values before restarting
 *  the counters with new values.
 */
template<unsigned int internalCounterBits = 64>
class ThreeFry2x64Fast : public ThreeFry2x64General<13, internalCounterBits>
{
    public:
        /*! \brief Construct ThreeFry random engine with 2x64 key values, 13 rounds.
         *
         *  \param key0   Random seed in the form of a 64-bit unsigned value.
         *  \param domain Random domain. This is used to guarantee that different
         *                applications of a random engine inside the code get different
         *                streams of random numbers, without requiring the user
         *                to provide lots of random seeds. Pick a value from the
         *                RandomDomain class, or RandomDomain::Other if it is
         *                not important. In the latter case you might want to use
         *                \ref gmx::DefaultRandomEngine instead.
         *
         *  \note The random domain is really another 64-bit seed value.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero.
         */
        ThreeFry2x64Fast(gmx_uint64_t key0 = 0, RandomDomain domain = RandomDomain::Other) : ThreeFry2x64General<13, internalCounterBits>(key0, domain) {}

        /*! \brief Construct ThreeFry random engine from 2x64-bit unsigned integers, 13 rounds.
         *
         *  This constructor assigns the raw 128 bit key data from unsigned integers.
         *  It is meant for the case when you want full control over the key,
         *  for instance to compare with reference values of the ThreeFry
         *  function during testing.
         *
         *  \param key0   First word of key/random seed.
         *  \param key1   Second word of key/random seed.
         *
         *  \throws InternalError if the high bits needed to encode the number of counter
         *          bits are nonzero. To test arbitrary values, use 0 internal counter bits.
         */
        ThreeFry2x64Fast(gmx_uint64_t key0, gmx_uint64_t key1) : ThreeFry2x64General<13, internalCounterBits>(key0, key1) {}
};



/*! \brief Default fast and accurate random engine in Gromacs
 *
 *  This engine will return 2*2^64 random results using the default
 *  gmx::RandomDomain::Other stream, and can be initialized with a single
 *  seed argument without having to remember empty template angle brackets.
 */
typedef ThreeFry2x64Fast<>                  DefaultRandomEngine;


/*! \brief Tabulated normal random distribution
 *
 *  Random distribution compatible with C++11 distributions - it can be
 *  used with any C++11 random engine.
 *
 *  \tparam RealType  Type of the return value. Float or double. Note that
 *                    GROMACS uses "real" type by default in contrast to the C++11
 *                    standard library, to avoid double/float conversions.
 *  \tparam tableBits Size of the table, specified in bits. The storage
 *                    space required is sizeof(RealType)*2^tableBits. To
 *                    keep things sane this is limited to 24 bits.
 *
 *  Some stochastic integrators depend on drawing a lot of normal
 *  distribution random numbers quickly, but in many cases the only
 *  important property is the distribution - given the noise in forces
 *  we do not need very high resolution.
 *  This distribution uses an internal table to return samples from a
 *  normal distribution with limited resolution. By default the table uses
 *  14 bits, but this is specified with a template parameter.
 *
 *  Since this distribution only uses tableBits bits per value generated,
 *  the values draw from the random engine are used for several results.
 *  To make sure you get a reproducible result when using counter-based
 *  random engines (such as ThreeFry2x64), remember to call the reset()
 *  method to cancel the internal memory of the distribution.
 *
 *  \note For modern NUMA systems, you likely want to use separate
 *        distributions for each thread, and make sure they are initialized
 *        on the CPU where they will run, so the table is placed in that
 *        NUMA memory pool.
 *  \note The finite table resolution means this distribution will NOT
 *        return arbitrarily small/large values, but with e.g. 14 bits
 *        the results are limited to roughly +/- 4 standard deviations.
 */
template<class RealType = real, unsigned int tableBits = 14>
class TabulatedNormalDistribution
{
    static_assert(tableBits <= 24, "Normal distribution table is limited to 24bits (64MB in single precision)");

    public:
        /*! \brief  Type of normal distribution results */
        typedef RealType result_type;

        /*! \brief  Normal distribution parameter class (mean and stddev) */
        class param_type
        {
            public:
                /*! \brief The type of distribution the parameters describe */
                typedef TabulatedNormalDistribution distribution_type;

                /*! \brief Constructor. Default is classical distr. with mean 0, stddev 1.
                 *
                 * \param mean     Expectation value.
                 * \param stddev   Standard deviation.
                 *
                 */
                explicit param_type(result_type mean = 0.0, result_type stddev = 1.0)
                    : mean_(mean), stddev_(stddev) {}

                /*! \brief Return mean parameter of normal distribution */
                result_type
                mean() const { return mean_; }

                /*! \brief Return standard deviation parameter of normal distribution */
                result_type
                stddev() const { return stddev_; }

                /*! \brief True if two sets of normal distributions parameters are identical
                 *
                 * \param x Instance to compare with.
                 */
                bool
                operator==(const param_type &x) const
                {
                    return (mean_ == x.mean_ && stddev_ == x.stddev_);
                }

                /*! \brief True if two sets of normal distributions parameters are different.
                 *
                 * \param x Instance to compare with.
                 */
                bool
                operator!=(const param_type &x) const { return !operator==(x); }

            private:
                /*! \brief Internal storage for mean of normal distribution */
                result_type mean_;
                /*! \brief Internal storage for standard deviation of normal distribution */
                result_type stddev_;
        };

    private:

        /*! \brief Fill the table with values for the normal distribution
         *
         *  This routine returns a new reference to a std::vector allocated on
         *  the heap. It will only be called to generate the static
         *  constant table data at initialization time. While it is technically
         *  returning memory on the heap, this does not use/leak more memory
         *  than what we would use by having the same table as a static member
         *  of the class.
         */
        static
        std::vector<RealType> &
        makeTable()
        {
            /* Fill the table with the integral of a gaussian distribution:
             */
            std::size_t            tableSize        = 1 << tableBits;
            std::size_t            halfSize         = (1 << tableBits)/2;
            double                 invSize          = 1.0/tableSize;
            double                 factor           = std::sqrt(2.0*M_PI);
            double                 x                = 0.5*factor*invSize;

            std::vector<RealType>* table  = new std::vector<RealType>(1ULL << tableBits);

            for (std::size_t i = 0; i < halfSize; i++)
            {
                if (i > 0)
                {
                    double dx;

                    if (i < halfSize-1)
                    {
                        double invNormal = factor*std::exp(0.5*x*x);
                        /* det is larger than 0 for all x, except the last */
                        double det = 1.0 - 2.0*invSize*x*invNormal;
                        dx = (1.0 - std::sqrt(det))/x;
                    }
                    else
                    {
                        dx = 1.0/x;
                    }
                    x = x + dx;
                }
                table->at(halfSize-1-i) = -x;
                table->at(halfSize+i)   =  x;
            }
            return *table;
        }

    public:

        /*! \brief Construct new normal distribution with specified mean & stdddev.
         *
         *  \param mean    Mean value of tabulated normal distribution
         *  \param stddev  Standard deviation of tabulated normal distribution
         */
        explicit TabulatedNormalDistribution(result_type mean = 0.0, result_type stddev = 1.0 )
            : param_(param_type(mean, stddev)), savedRandomBits_(0), savedRandomBitsLeft_(0)
        {
        }

        /*! \brief Construct new normal distribution from parameter type.
         *
         *  \param param Parameter class containing mean and standard deviation.
         */
        explicit TabulatedNormalDistribution(  const param_type &param )
            : param_(param), savedRandomBits_(0), savedRandomBitsLeft_(0)
        {
        }

        /*! \brief Smallest value that can be generated in normal distrubiton.
         *
         * \note The smallest value is not -infinity with a table, but it
         *       depends on the table resolution. With 14 bits, this is roughly
         *       four standard deviations below the mean.
         */
        result_type
        min() const
        {
            return c_table_[0];
        }

        /*! \brief Largest value that can be generated in normal distribution.
         *
         * \note The largest value is not infinity with a table, but it
         *       depends on the table resolution. With 14 bits, this is roughly
         *       four standard deviations above the mean.
         */
        result_type
        max() const
        {
            return c_table_[c_table_.size()-1];
        }

        /*! \brief Mean of the present normal distribution */
        result_type
        mean() const
        {
            return param_.mean();
        }

        /*! \brief Standard deviation of the present normal distribution */

        result_type
        stddev() const
        {
            return param_.stddev();
        }

        /*! \brief The parameter class (mean & stddev) of the normal distribution */
        param_type
        param() const
        {
            return param_;
        }

        /*! \brief Clear all internal saved random bits from the random engine */
        void
        reset()
        {
            savedRandomBitsLeft_ = 0;
        }

        /*! \brief Return normal distribution value specified by internal parameters.
         *
         * \tparam Rng   Random engine type used to provide uniform random bits.
         * \param  g     Random engine of class Rng. For normal GROMACS usage
         *               you likely want to use ThreeFry2x64.
         */
        template<class Rng>
        result_type
        operator()(Rng &g)
        {
            return (*this)(g, param_);
        }

        /*! \brief Return normal distribution value specified by given parameters
         *
         * \tparam Rng   Random engine type used to provide uniform random bits.
         * \param  g     Random engine of class Rng. For normal GROMACS usage
         *               you likely want to use ThreeFry2x64.
         * \param  param Parameters used to specify normal distribution.
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            if (savedRandomBitsLeft_ < tableBits)
            {
                // We do not know whether the generator g returns 64 or 32 bits,
                // since g is not known when we construct this class.
                // To keep things simple, we always draw one random number,
                // store it in our 64-bit value, and set the number of active bits.
                // For tableBits up to 16 this will be as efficient both with 32
                // and 64 bit random engines when drawing multiple numbers
                // (our default value is 14), It also avoids drawing multiple
                // 32-bit random numbres even if we just call this routine for a
                // single result.
                savedRandomBits_     = static_cast<gmx_uint64_t>(g());
                savedRandomBitsLeft_ = std::numeric_limits<typename Rng::result_type>::digits;
            }
            result_type value        = c_table_[savedRandomBits_ & ( (1ULL << tableBits) - 1 ) ];
            savedRandomBits_       >>= tableBits;
            savedRandomBitsLeft_    -= tableBits;
            return param.mean() + value * param.stddev();
        }

        /*!\brief Check if two tabulated normal distributions have identical states.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator==(const TabulatedNormalDistribution<RealType, tableBits> &x) const
        {
            return (param_ == x.param_ &&
                    savedRandomBits_ == x.savedRandomBits_ &&
                    savedRandomBitsLeft_ == x.savedRandomBitsLeft_);
        }

        /*!\brief Check if two tabulated normal distributions have different states.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator!=(const TabulatedNormalDistribution<RealType, tableBits> &x) const
        {
            return !operator==(x);
        }

    private:
        /*! \brief Parameters of normal distribution (mean and stddev) */
        param_type                                                   param_;
        /*! \brief Array with tabluated values of normal distribution */
        static const std::vector<RealType>                           c_table_;
        /*! \brief Saved output from random engine, shifted tableBits right each time */
        gmx_uint64_t                                                 savedRandomBits_;
        /*! \brief Number of valid bits remaining i savedRandomBits_ */
        unsigned int                                                 savedRandomBitsLeft_;

        GMX_DISALLOW_COPY_AND_ASSIGN(TabulatedNormalDistribution);
};

// MSVC does not handle extern template class members correctly even in MSVC 2015,
// so in that case we have to instantiate in every object using it. In addition,
// doxygen is convinced this defines a function (which leads to crashes in our python
// scripts), so to avoid confusion we hide it from doxygen too.
#if (!defined(_MSC_VER) || defined(__INTEL_COMPILER)) && !defined(DOXYGEN)
// Declaration of template specialization
template<>
const std::vector<real> TabulatedNormalDistribution<real, 14>::c_table_;

extern template
const std::vector<real> TabulatedNormalDistribution<real, 14>::c_table_;
#endif

// Instantiation for all tables without specialization
template<class RealType, unsigned int tableBits>
const std::vector<RealType> TabulatedNormalDistribution<RealType, tableBits>::c_table_ = TabulatedNormalDistribution<RealType, tableBits>::makeTable();



/*! \brief Uniform integer distribution
 *
 *  The C++ standard library does provide this distribution, but even
 *  though they all sample from the correct distribution different standard
 *  library implementations appear to return different sequences of numbers
 *  for the same random number generator. To make it easier to use GROMACS
 *  unit tests that depend on random numbers we have our own implementation.
 *
 * \tparam IntType Integer type, int by default.
 */
template<class IntType = int>
class UniformIntDistribution
{
    public:
        /*! \brief Type of values returned */
        typedef IntType result_type;

        /*! \brief Uniform int distribution parameters */
        class param_type
        {
            /*! \brief Lower end of range (inclusive) */
            result_type  a_;
            /*! \brief Upper end of range (inclusive) */
            result_type  b_;

            public:
                /*! \brief Reference back to the distribution class */
                typedef UniformIntDistribution distribution_type;

                /*! \brief Construct parameter block
                 *
                 * \param a   Lower end of range (inclusive)
                 * \param b   Upper end of range (inclusive)
                 */
                explicit param_type(result_type a = 0, result_type b = std::numeric_limits<result_type>::max())
                    : a_(a), b_(b)
                {
                    GMX_RELEASE_ASSERT(a <= b, "The uniform integer distribution requires a<=b");
                }

                /*! \brief Return lower range */
                result_type a() const { return a_; }
                /*! \brief Return upper range */
                result_type b() const { return b_; }

                /*! \brief True if two parameter sets will return the same uniform int distribution.
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator==(const param_type &x) const
                {
                    // rangeBits is a function of a & b, so it does not have to be tested
                    return a_ == x.a_ && b_ == x.b_;
                }

                /*! \brief True if two parameter sets will return different uniform int distributions
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator!=(const param_type &x) const { return !operator==(x); }
        };

    public:

        /*! \brief Construct new distribution with given integer parameters.
         *
         * \param a   Lower end of range (inclusive)
         * \param b   Upper end of range (inclusive)
         */
        explicit UniformIntDistribution(result_type a = 0, result_type b = std::numeric_limits<result_type>::max())
            : param_(param_type(a, b)), savedRandomBits_(0), savedRandomBitsLeft_(0) {}

        /*! \brief Construct new distribution from parameter class
         *
         * \param param  Parameter class as defined inside gmx::UniformIntDistribution.
         */
        explicit UniformIntDistribution(const param_type &param)
            : param_(param), savedRandomBits_(0), savedRandomBitsLeft_(0) {}

        /*! \brief Flush all internal saved values  */
        void
        reset() { savedRandomBitsLeft_ = 0; }

        /*! \brief Return values from uniform int distribution with internal parameters
         *
         * \tparam Rng  Uniform random engine class
         *
         * \param  g    Random engine
         */
        template<class Rng>
        result_type
        operator()(Rng &g) { return (*this)(g, param_); }

        /*! \brief Return value from uniform int distribution with given parameters
         *
         * \tparam Rng   Uniform random engine class
         *
         * \param  g     Random engine
         * \param  param Parameters to use
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            static_assert(sizeof(typename Rng::result_type) >= sizeof(gmx_uint32_t),
                          "The random engine result_type should be 32 or 64 bits");

            result_type  range = param.b() - param.a();
            unsigned int rangeBits;
            result_type  result;

            if (range == 0)
            {
                return param.a();
            }
            else if (range == std::numeric_limits<result_type>::max())
            {
                rangeBits = std::numeric_limits<result_type>::digits; // Use all bits in type
            }
            else
            {
                if (sizeof(result_type) == sizeof(gmx_uint32_t))
                {
                    rangeBits = gmx_log2i(static_cast<gmx_uint32_t>(range));
                }
                else
                {
                    rangeBits = gmx_log2i_64(range);
                }
                rangeBits += ((range >> rangeBits) > 0);
            }

            do
            {
                if (savedRandomBitsLeft_ < rangeBits)
                {
                    savedRandomBits_     = static_cast<gmx_uint64_t>(g());
                    savedRandomBitsLeft_ = std::numeric_limits<typename Rng::result_type>::digits;

                    if (sizeof(typename Rng::result_type) == sizeof(gmx_uint32_t))
                    {
                        savedRandomBits_    <<= std::numeric_limits<gmx_uint32_t>::digits;
                        savedRandomBits_     |= g();
                        savedRandomBitsLeft_ += std::numeric_limits<gmx_uint32_t>::digits;
                    }
                }
                result                   = savedRandomBits_;
                savedRandomBits_       >>= rangeBits;
                result                   = result - (savedRandomBits_ << rangeBits);
                savedRandomBitsLeft_    -= rangeBits;
            }
            while (result > range);

            return result + param.a();
        }

        /*! \brief Return the lower range uniform int distribution */
        result_type
        a() const { return param_.a(); }

        /*! \brief Return the upper range of the uniform int distribution */
        result_type
        b() const { return param_.b(); }

        /*! \brief Return the full parameter class of the uniform int distribution */
        param_type param() const { return param_; }

        /*! \brief Smallest value that can be returned from uniform int distribution */
        result_type
        min() const { return a(); }

        /*! \brief Largest value that can be returned from uniform int distribution */
        result_type
        max() const { return b(); }

        /*! \brief True if two uniform int distributions will produce the same values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator==(const UniformIntDistribution &x) const
        { return param_ == x.param_; }

        /*! \brief True if two uniform int distributions will produce different values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator!=(const UniformIntDistribution &x) const
        { return !operator==(x); }

        GMX_DISALLOW_COPY_AND_ASSIGN(UniformIntDistribution);

    private:
        /*! \brief Internal value for parameters, can be overridden at generation time. */
        param_type      param_;
        /*! \brief Saved output from random engine, shifted tableBits right each time */
        gmx_uint64_t    savedRandomBits_;
        /*! \brief Number of valid bits remaining i savedRandomBits_ */
        unsigned int    savedRandomBitsLeft_;
};


/*! \brief Generate a floating-point value with specified number of random bits
 *
 * \tparam RealType  Floating-point type to generate
 * \tparam Bits      Number of random bits to generate
 * \tparam Rng       Random number generator class
 *
 * \param  g         Random number generator to use
 *
 * This implementation avoids the bug in libc++ and stdlibc++ (which is due
 * to the C++ standard being unclear) where 1.0 can be returned occasionally.
 *
 */
template<class RealType = real, std::size_t Bits, class Rng>
RealType
generateCanonical(Rng &g)
{
    // No point in using more bits than fit in RealType
    const std::size_t digits   = std::numeric_limits<RealType>::digits;
    const std::size_t realBits = std::min(digits, Bits);
    const double      r        = 1.0 + static_cast<double>(Rng::max() - Rng::min());
    const std::size_t log2R    = std::log2(r);
    const std::size_t k        = realBits / log2R + (realBits % log2R != 0) + (realBits == 0);

    RealType          base     = r;
    RealType          s        = g() - Rng::min();
    RealType          result;

    for (std::size_t i = 1; i < k; ++i, base *= r)
    {
        s += (g() - Rng::min()) * base;
    }
    result = s / base;

    // This implementation is specified by the C++ standard, but unfortunately it
    // has a bug where 1.0 can be generated occasionally due to the limited
    // precision of floating point, while 0.0 is only generated half as often as
    // it should. We "solve" both these issues by swapping 1.0 for 0.0 when it happens.
    //
    // See:
    // https://llvm.org/bugs/show_bug.cgi?id=18767
    // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176
    //
    // Note that we prefer not to use the gcc 'fix' of looping until the result
    // is smaller than 1.0, since that breaks the strict specification of the
    // number of times the rng will be called.
    //
    // This can only happen when we ask for the same number of bits that fit
    // in RealType, so by checking for that we avoid the extra code in all other
    // cases. If you are worried about it: Use RealType=double with 32 bits.
    //
    if (realBits == digits && result == 1.0)
    {
        result = 0.0;
    }
    return result;
}


/*! \brief Uniform real distribution
 *
 *  The C++ standard library does provide this distribution, but even
 *  though they all sample from the correct distribution different standard
 *  library implementations appear to return different sequences of numbers
 *  for the same random number generator. To make it easier to use GROMACS
 *  unit tests that depend on random numbers we have our own implementation.
 *
 * \tparam RealType Floating-point type, real by default in GROMACS.
 */
template<class RealType = real>
class UniformRealDistribution
{
    public:
        /*! \brief Type of values returned */
        typedef RealType result_type;

        /*! \brief Uniform real distribution parameters */
        class param_type
        {
            /*! \brief Lower end of range (inclusive) */
            result_type  a_;
            /*! \brief Upper end of range (exclusive) */
            result_type  b_;

            public:
                /*! \brief Reference back to the distribution class */
                typedef UniformRealDistribution distribution_type;

                /*! \brief Construct parameter block
                 *
                 * \param a   Lower end of range (inclusive)
                 * \param b   Upper end of range (exclusive)
                 */
                explicit param_type(result_type a = 0.0, result_type b = 1.0)
                    : a_(a), b_(b)
                {
                    GMX_RELEASE_ASSERT(a < b, "The uniform real distribution requires a<b");
                }

                /*! \brief Return first parameter */
                result_type a() const { return a_; }
                /*! \brief Return second parameter */
                result_type b() const { return b_; }

                /*! \brief True if two parameter sets will return the same uniform real distribution.
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator==(const param_type &x) const
                {
                    return a_ == x.a_ && b_ == x.b_;
                }

                /*! \brief True if two parameter sets will return different uniform real distributions
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator!=(const param_type &x) const { return !operator==(x); }
        };

    public:

        /*! \brief Construct new distribution with given floating-point parameters.
         *
         * \param a   Lower end of range (inclusive)
         * \param b   Upper end of range (exclusive)
         */
        explicit UniformRealDistribution(result_type a = 0.0, result_type b = 1.0)
            : param_(param_type(a, b)) {}

        /*! \brief Construct new distribution from parameter class
         *
         * \param param  Parameter class as defined inside gmx::UniformRealDistribution.
         */
        explicit UniformRealDistribution(const param_type &param) : param_(param) {}

        /*! \brief Flush all internal saved values  */
        void
        reset() { }

        /*! \brief Return values from uniform real distribution with internal parameters
         *
         * \tparam Rng  Random engine class
         *
         * \param  g    Random engine
         */
        template<class Rng>
        result_type
        operator()(Rng &g) { return (*this)(g, param_); }

        /*! \brief Return value from uniform real distribution with given parameters
         *
         * \tparam Rng   Random engine class
         *
         * \param  g     Random engine
         * \param  param Parameters to use
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            return (param.b() - param.a())*generateCanonical<RealType, std::numeric_limits<RealType>::digits>(g) + param.a();
        }

        /*! \brief Return the lower range uniform real distribution */
        result_type
        a() const { return param_.a(); }

        /*! \brief Return the upper range of the uniform real distribution */
        result_type
        b() const { return param_.b(); }

        /*! \brief Return the full parameter class of the uniform real distribution */
        param_type param() const { return param_; }

        /*! \brief Smallest value that can be returned from uniform real distribution */
        result_type
        min() const { return a(); }

        /*! \brief Largest value that can be returned from uniform real distribution */
        result_type
        max() const { return b(); }

        /*! \brief True if two uniform real distributions will produce the same values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator==(const UniformRealDistribution &x) const
        { return param_ == x.param_; }

        /*! \brief True if two uniform real distributions will produce different values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator!=(const UniformRealDistribution &x) const
        { return !operator==(x); }

        GMX_DISALLOW_COPY_AND_ASSIGN(UniformRealDistribution);

    private:

        /*! \brief Internal value for parameters, can be overridden at generation time. */
        param_type param_;
};




/*! \brief Exponential distribution
 *
 *  The C++ standard library does provide an exponential distribution, but even
 *  though they all sample from a correct distribution, different standard
 *  library implementations appear to return different sequences of numbers
 *  for the same random number generator. To make it easier to use GROMACS
 *  unit tests that depend on random numbers we have our own implementation.
 *
 * \tparam RealType Floating-point type, real by default in GROMACS.
 */
template<class RealType = real>
class ExponentialDistribution
{
    public:
        /*! \brief Type of values returned */
        typedef RealType result_type;

        /*! \brief Exponential distribution parameters */
        class param_type
        {
            /*! \brief The lambda/decay parameter */
            result_type  lambda_;

            public:
                /*! \brief Reference back to the distribution class */
                typedef ExponentialDistribution distribution_type;

                /*! \brief Construct parameter block
                 *
                 * \param lambda   lambda/decay parameter
                 */
                explicit param_type(result_type lambda = 1.0)
                    : lambda_(lambda) {}

                /*! \brief Return lambda parameter */
                result_type lambda() const { return lambda_; }

                /*! \brief True if two parameter sets will return the same exponential distribution.
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator==(const param_type &x) const
                {
                    return lambda_ == x.lambda_;
                }

                /*! \brief True if two parameter sets will return different exponential distributions
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator!=(const param_type &x) const { return !operator==(x); }
        };

    public:

        /*! \brief Construct new distribution with given floating-point parameter.
         *
         * \param lambda   lambda/decay parameter

         */
        explicit ExponentialDistribution(result_type lambda = 1.0)
            : param_(param_type(lambda)) {}

        /*! \brief Construct new distribution from parameter class
         *
         * \param param  Parameter class as defined inside gmx::ExponentialDistribution.
         */
        explicit ExponentialDistribution(const param_type &param) : param_(param) {}

        /*! \brief Flush all internal saved values  */
        void
        reset() {}

        /*! \brief Return values from exponential distribution with internal parameters
         *
         *  \tparam Rng   Random engine class
         *
         *  \param  g     Random engine
         */
        template<class Rng>
        result_type
        operator()(Rng &g) { return (*this)(g, param_); }

        /*! \brief Return value from exponential distribution with given parameters
         *
         *  \tparam Rng   Random engine class
         *
         *  \param  g     Random engine
         *  \param  param Parameters to use
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            return -std::log(result_type(1) -
                             generateCanonical<result_type,
                                               std::numeric_limits<result_type>::digits>(g)) / param.lambda();
        }

        /*! \brief Return the lambda parameter of the exponential distribution */
        result_type
        lambda() const { return param_.lambda(); }

        /*! \brief Return the full parameter class of exponential distribution */
        param_type param() const { return param_; }

        /*! \brief Smallest value that can be returned from exponential distribution */
        result_type
        min() const { return 0; }

        /*! \brief Largest value that can be returned from exponential distribution */
        result_type
        max() const { return std::numeric_limits<result_type>::infinity(); }

        /*! \brief True if two exponential distributions will produce the same values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator==(const ExponentialDistribution &x) const
        { return param_ == x.param_; }

        /*! \brief True if two exponential distributions will produce different values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator!=(const ExponentialDistribution &x) const
        { return !operator==(x); }

        GMX_DISALLOW_COPY_AND_ASSIGN(ExponentialDistribution);

    private:

        /*! \brief Internal value for parameters, can be overridden at generation time. */
        param_type param_;

};



/*! \brief Gamma distribution
 *
 *  The C++ standard library does provide a gamma distribution, but when
 *  using libstdc++-4.4.7 with at least gcc-4.6 or icc-14.0 the headers
 *  produce errors. Even for newer compilers, libstdc++ and libc++ appear to
 *  use different algorithms to generate it, which means their values differ
 *  in contrast to the uniform and normal distributions where they are
 *  identical. To avoid both the gcc-4.6 bug and make it easier to use GROMACS
 *   unit tests that depend on random numbers we have our own implementation.
 *
 *  Be warned that the gamma distribution works like the standard
 *  normal distribution and keeps drawing values from the random engine
 *  in a loop, so you want to make sure you use a random stream with a
 *  very large margin to make sure you do not run out of random numbers
 *  in an unlucky case (which will lead to an exception with the GROMACS
 *  default random engine).
 *
 *  The gamma distribution is defined as
 *
 * \f[
 *     p(x|\alpha,\beta) = \frac{1}{\Gamma(\alpha)\beta^{alpha}} x^{\alpha - 1} e^{-\frac{x}{\beta}}, x\geq 0
 * \f]
 *
 * \tparam RealType Floating-point type, real by default in GROMACS.
 */
template<class RealType = real>
class GammaDistribution
{
    public:
        /*! \brief Type of values returned */
        typedef RealType result_type;

        /*! \brief Gamma distribution parameters */
        class param_type
        {
            /*! \brief First parameter of gamma distribution */
            result_type  alpha_;
            /*! \brief Second parameter of gamma distribution */
            result_type  beta_;

            public:
                /*! \brief Reference back to the distribution class */
                typedef GammaDistribution distribution_type;

                /*! \brief Construct parameter block
                 *
                 * \param alpha  First parameter of gamma distribution
                 * \param beta   Second parameter of gamma distribution
                 */
                explicit param_type(result_type alpha = 1.0, result_type beta = 1.0)
                    : alpha_(alpha), beta_(beta) {}

                /*! \brief Return first parameter */
                result_type alpha() const { return alpha_; }
                /*! \brief Return second parameter */
                result_type beta()  const { return beta_; }

                /*! \brief True if two parameter sets will return the same distribution.
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator==(const param_type &x) const
                {
                    return alpha_ == x.alpha_ && beta_ == x.beta_;
                }

                /*! \brief True if two parameter sets will return different distributions
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator!=(const param_type &x) const { return !operator==(x); }
        };

    public:

        /*! \brief Construct new distribution with given floating-point parameters.
         *
         * \param alpha  First parameter of gamma distribution
         * \param beta   Second parameter of gamma distribution
         */
        explicit GammaDistribution(result_type alpha = 1.0, result_type beta = 1.0)
            : param_(param_type(alpha, beta)) {}

        /*! \brief Construct new distribution from parameter class
         *
         * \param param  Parameter class as defined inside gmx::GammaDistribution.
         */
        explicit GammaDistribution(const param_type &param) : param_(param) {}

        /*! \brief Flush all internal saved values  */
        void
        reset() {}

        /*! \brief Return values from gamma distribution with internal parameters
         *
         *  \tparam Rng   Random engine class
         *
         *  \param  g     Random engine
         */
        template<class Rng>
        result_type
        operator()(Rng &g) { return (*this)(g, param_); }

        /*! \brief Return value from gamma distribution with given parameters
         *
         *  \tparam Rng   Random engine class
         *
         *  \param  g     Random engine
         *  \param  param Parameters to use
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            result_type                            alpha = param.alpha();
            UniformRealDistribution<result_type>   uniformDist(0, 1);
            ExponentialDistribution<result_type>   expDist;

            result_type x;

            if (alpha == 1.0)
            {
                x = expDist(g);
            }
            else if (alpha > 1.0)
            {
                const result_type b = alpha - 1.0;
                const result_type c = 3.0 * alpha - result_type(0.75);

                while (true)
                {
                    const result_type u = uniformDist(g);
                    const result_type v = uniformDist(g);
                    const result_type w = u * (1 - u);

                    if (w != 0)
                    {
                        const result_type y = std::sqrt(c / w) *
                            (u - result_type(0.5));
                        x = b + y;

                        if (x >= 0)
                        {
                            const result_type z = 64 * w * w * w * v * v;

                            if (z <= 1.0 - 2.0 * y * y / x)
                            {
                                break;
                            }
                            if (std::log(z) <= 2.0 * (b * std::log(x / b) - y))
                            {
                                break;
                            }
                        }
                    }
                }
            }
            else  // __a < 1
            {
                while (true)
                {
                    const result_type u  = uniformDist(g);
                    const result_type es = expDist(g);

                    if (u <= 1.0 - alpha)
                    {
                        x = std::pow(u, 1.0 / alpha);

                        if (x <= es)
                        {
                            break;
                        }
                    }
                    else
                    {
                        const result_type e = -std::log((1.0 - u)/alpha);
                        x = std::pow(1.0 - alpha + alpha * e, 1.0 / alpha);

                        if (x <= e + es)
                        {
                            break;
                        }
                    }
                }
            }
            return x * param.beta();
        }

        /*! \brief Return the first parameter of gamma distribution */
        result_type
        alpha() const { return param_.alpha(); }

        /*! \brief Return the second parameter of gamma distribution */
        result_type
        beta() const { return param_.beta(); }

        /*! \brief Return the full parameter class of gamma distribution */
        param_type param() const { return param_; }

        /*! \brief Smallest value that can be returned from gamma distribution */
        result_type
        min() const { return 0; }

        /*! \brief Largest value that can be returned from gamma distribution */
        result_type
        max() const { return std::numeric_limits<result_type>::infinity(); }

        /*! \brief True if two gamma distributions will produce the same values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator==(const GammaDistribution &x) const
        { return param_ == x.param_; }

        /*! \brief True if two gamma distributions will produce different values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator!=(const GammaDistribution &x) const
        { return !operator==(x); }

        GMX_DISALLOW_COPY_AND_ASSIGN(GammaDistribution);

    private:

        /*! \brief Internal value for parameters, can be overridden at generation time. */
        param_type param_;
};


/*! \brief Normal distribution
 *
 *  The C++ standard library does provide a normal distribution, but even
 *  though they all sample from the normal distribution different standard
 *  library implementations appear to return different sequences of numbers
 *  for the same random number generator. To make it easier to use GROMACS
 *  unit tests that depend on random numbers we have our own implementation.
 *
 *  Be warned that the normal distribution draws values from the random engine
 *  in a loop, so you want to make sure you use a random stream with a
 *  very large margin to make sure you do not run out of random numbers
 *  in an unlucky case (which will lead to an exception with the GROMACS
 *  default random engine).
 *
 * \tparam RealType Floating-point type, real by default in GROMACS.
 */
template<class RealType = real>
class NormalDistribution
{
    public:
        /*! \brief Type of values returned */
        typedef RealType result_type;

        /*! \brief Normal distribution parameters */
        class param_type
        {
            /*! \brief Mean of normal distribution */
            result_type  mean_;
            /*! \brief Standard deviation of distribution */
            result_type  stddev_;

            public:
                /*! \brief Reference back to the distribution class */
                typedef NormalDistribution distribution_type;

                /*! \brief Construct parameter block
                 *
                 * \param mean     Mean of normal distribution
                 * \param stddev   Standard deviation of normal distribution
                 */
                explicit param_type(result_type mean = 0.0, result_type stddev = 1.0)
                    : mean_(mean), stddev_(stddev) {}

                /*! \brief Return first parameter */
                result_type mean() const { return mean_; }
                /*! \brief Return second parameter */
                result_type stddev()  const { return stddev_; }

                /*! \brief True if two parameter sets will return the same normal distribution.
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator==(const param_type &x) const
                {
                    return mean_ == x.mean_ && stddev_ == x.stddev_;
                }

                /*! \brief True if two parameter sets will return different normal distributions
                 *
                 * \param x  Instance to compare with.
                 */
                bool
                operator!=(const param_type &x) const { return !operator==(x); }
        };

    public:

        /*! \brief Construct new distribution with given floating-point parameters.
         *
         * \param mean     Mean of normal distribution
         * \param stddev   Standard deviation of normal distribution
         */
        explicit NormalDistribution(result_type mean = 0.0, result_type stddev = 1.0)
            : param_(param_type(mean, stddev)), hot_(false), saved_(0) {}

        /*! \brief Construct new distribution from parameter class
         *
         * \param param  Parameter class as defined inside gmx::NormalDistribution.
         */
        explicit NormalDistribution(const param_type &param)
            : param_(param), hot_(false), saved_(0) {}

        /*! \brief Flush all internal saved values  */
        void
        reset() { hot_ = false; }

        /*! \brief Return values from normal distribution with internal parameters
         *
         *  \tparam Rng   Random engine class
         *
         *  \param  g     Random engine
         */
        template<class Rng>
        result_type
        operator()(Rng &g) { return (*this)(g, param_); }

        /*! \brief Return value from normal distribution with given parameters
         *
         *  \tparam Rng   Random engine class
         *
         *  \param  g     Random engine
         *  \param  param Parameters to use
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            result_type result;

            if (hot_)
            {
                hot_   = false;
                result = saved_;
            }
            else
            {
                UniformRealDistribution<result_type> uniformDist(-1.0, 1.0);
                result_type u;
                result_type v;
                result_type s;

                do
                {
                    u = uniformDist(g);
                    v = uniformDist(g);
                    s = u * u + v * v;
                }
                while (s > 1.0 || s == 0.0);

                s      = std::sqrt(-2.0 * std::log(s) / s);
                saved_ = v * s;
                hot_   = true;
                result = u * s;
            }
            return result * param.stddev() + param.mean();
        }

        /*! \brief Return the mean of the normal distribution */
        result_type
        mean() const { return param_.mean(); }

        /*! \brief Return the standard deviation of the normal distribution */
        result_type
        stddev() const { return param_.stddev(); }

        /*! \brief Return the full parameter class of the normal distribution */
        param_type param() const { return param_; }

        /*! \brief Smallest value that can be returned from normal distribution */
        result_type
        min() const { return -std::numeric_limits<result_type>::infinity(); }

        /*! \brief Largest value that can be returned from normal distribution */
        result_type
        max() const { return std::numeric_limits<result_type>::infinity(); }

        /*! \brief True if two normal distributions will produce the same values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator==(const NormalDistribution &x) const
        {
            /* Equal if: Params are identical, and saved-state is identical,
             * and if we have something saved, it must be identical.
             */
            return param_ == x.param_ && hot_ == x.hot_ && (!hot_ || saved_ == x.saved_);
        }

        /*! \brief True if two normal distributions will produce different values.
         *
         * \param  x     Instance to compare with.
         */
        bool
        operator!=(const NormalDistribution &x) const
        { return !operator==(x); }

        GMX_DISALLOW_COPY_AND_ASSIGN(NormalDistribution);

    private:

        /*! \brief Internal value for parameters, can be overridden at generation time. */
        param_type  param_;
        /*! \brief True if there is a saved result to return */
        bool        hot_;
        /*! \brief The saved result to return - only valid if hot_ is true */
        result_type saved_;
};


}      // namespace gmx

#endif // GMX_MATH_RANDOM_H
