/*
 * This file is part of the GROMACS molecular simulation package.
 *
 * Copyright (c) 2015, by the GROMACS development team, led by
 * Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,
 * and including many others, as listed in the AUTHORS file in the
 * top-level source directory and at http://www.gromacs.org.
 *
 * GROMACS is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1
 * of the License, or (at your option) any later version.
 *
 * GROMACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with GROMACS; if not, see
 * http://www.gnu.org/licenses, or write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.
 *
 * If you want to redistribute modifications to GROMACS, please
 * consider that scientific software is very special. Version
 * control is crucial - bugs must be traceable. We will be happy to
 * consider code for inclusion in the official distribution, but
 * derived work must not be called official GROMACS. Details are found
 * in the README & COPYING files - if they are missing, get the
 * official version at http://www.gromacs.org.
 *
 * To help us fund GROMACS development, we humbly ask that you cite
 * the research papers on the package. Check out http://www.gromacs.org.
 */

/*! \file
 * \brief Random number utility functions for GROMACS
 *
 * Random number utilities compatible with C++11, but more optimized
 * for usage in molecular simulation applications.
 *
 * \author Erik Lindahl <erik.lindahl@gmail.com>
 * \inpublicapi
 * \ingroup module_math
 */

#ifndef GMX_MATH_RANDOM_H
#define GMX_MATH_RANDOM_H

#include <cmath>

#include <algorithm>
#include <iostream>
#include <limits>

#include <array>
#include <mutex>
#include <type_traits>

#include "gromacs/math/utilities.h"
#include "gromacs/utility/basedefinitions.h"
#include "gromacs/utility/exceptions.h"

/*
 * The GROMACS implementation of the ThreeFry random engine has been
 * heavily inspired by the versions proposed to Boost by:
 *
 * John Salmon, Copyright 2010-2014 by D. E. Shaw Research
 * https://github.com/DEShawResearch/Random123-Boost
 *
 * Thijs van den Berg, Copyright (c) 2014 M.A. (Thijs) van den Berg
 * https://github.com/sitmo/threefry
 *
 * Both of them are covered by the Boost Software License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */


namespace gmx
{

/*! \brief Return 64 random bits from the random device, suitable as seed.
 *
 *  \return 64-bit unsigned integer with random bits.
 */
gmx_uint64_t
makeRandomSeed();

/*! \brief Enumerated values for fixed part of random seed (domain)
 *
 *  Random numbers are used in many places in GROMACS, and to avoid identical
 *  streams the random seeds should be different. Instead of keeping track of
 *  several different user-provided seeds, it is better to use the fact that
 *  ThreeFry2x64 takes two 64-bit keys (and ThreeFry4x64 four of them), and
 *  combine a general user-provided 64-bit random seed with a second constant
 *  value from this list to make each stream guaranteed unique.
 *
 *  \note There is no reason to go overboard with adding options; we only
 *        need to guarantee different streams for cases that might be present
 *        simultaneously in a single simulation. As an example, two different
 *        integrators (or thermostats) can reuse the same domain.
 *  \note When you do add options, leave some space between the values so
 *        you can group new options with old ones without changing old values.
 *
 *  \note Since this value is used as an unsigned integer constant in the random
 *        engine constructor or seed call, we avoid using a class enum.
 */
enum RandomDomain
{
    RandomDomain_Other                    = 0x00000000,   //!< Generic - stream uniqueness is not important
    RandomDomain_MaxwellVelocities        = 0x00001000,   //!< Veolcity assignment from Maxwell distribution
    RandomDomain_TestParticleInsertion    = 0x00002000,   //!< Test particle insertion
    RandomDomain_UpdateCoordinates        = 0x00003000,   //!< Particle integrators
    RandomDomain_UpdateConstraints        = 0x00004000,   //!< Second integrator step for constraints
    RandomDomain_Thermostat               = 0x00005000,   //!< Stochastic temperature coupling
    RandomDomain_Barostat                 = 0x00006000,   //!< Stochastic pressure coupling
    RandomDomain_ReplicaExchange          = 0x00007000,   //!< Replica exchange metropolis moves
    RandomDomain_ExpandedEnsemble         = 0x00008000    //!< Expanded ensemble lambda moves
};


/*! \brief Implementation class for all ThreeFry counter-based random engines.
 *
 *  This class is used to implement several different ThreeFry random engines
 *  differing in the number of words used, the number of rounds executed in
 *  each iteration, and the number of bits reserved for the internal counter.
 *  It is compatible with C++11 random engines, and can be used e.g. with all
 *  random distributions from the standard library.
 *
 *  ThreeFry is a counter-based rather than state-based random engine. This
 *  means that we seed it with a "key", after which we can get the
 *  N:th random number in a sequence (specified by a counter) directly. This
 *  means we are guaranteed the same sequence of numbers even when running in
 *  parallel if using e.g. step and atom index as counters.
 *
 *  However, it is also useful to be able to use it as a normal random engine,
 *  for instance if you need more than 2/4 random values for a specific counter,
 *  not to mention where you just need good normal random numbers.
 *  To achieve this, this implementation uses John Salmon's idea of reserving
 *  a couple of the highest bits in the user-provided counter for an internal
 *  counter. For instance, if reserving 3 bits, this means you get a stream of
 *  8 iterations (each with 2/4 random values) after every restart. If you call
 *  the engine after these bits have been exhausted, it will throw an
 *  exception to make sure you don't get overlapping streams by mistake.
 *  Reserving 3 bits also means you can only use 64-3=61 bits of the highest
 *  word when restarting (i.e., setting) the counters.
 *
 *  This version also supports using internalCounterBits=0. In this case the
 *  random engine will be able to return a single counter round, i.e. 2 64-bit
 *  values for the 2x64 flavor, and 4 values for 4x64, after which an exception
 *  is thrown. In this case no high bits are reserved, which means the class
 *  implements the raw ThreeFry64 random functions.
 *
 *  \tparam nWords  This can only be 2 or 4. Using 4 words achieves the highest
 *                  raw performance (random bytes/clock), but that assumes you
 *                  actually use 4*64bits before restarting the engine with a
 *                  new counter value. The 4x64is also useful if you want the
 *                  flexibilty to use several large 64-bit counters and still
 *                  be sure no two combinations will ever produce identical
 *                  streams of random numbers.
 *                  However, for the common case where we only use a few values
 *                  before restarting, it will be faster to stick to two words.
 *  \tparam rounds  The number of encryption iterations used when generating.
 *                  This can in principle be any value, but 20 rounds has been
 *                  shown to pass all BigCrush random tests, and with 13 rounds
 *                  only one fails. This is a very stringent test, and the
 *                  standard Mersenne Twister engine fails two, so 13 rounds
 *                  should be a perfectly fine balance in most cases.
 *  \tparam internalCounterBits
 *                  Number of high bits in the user-provided counter reserved
 *                  for the internal counter. The number of values the engine
 *                  can return after each restart will be
 *                  nWords*2^internalCounterBits.
 */
template<unsigned int nWords, unsigned int rounds, unsigned int internalCounterBits>
class ThreeFry64
{
    static_assert(nWords == 2 || nWords == 4, "ThreeFry64 only works with wordsizes 2 or 4.");

    public:
        // result_type must be lower case to be compatible with C++11 standard library

        /*! \brief Integer type for output. */
        typedef gmx_uint64_t                    result_type;
        /*! \brief Use array for counter & key states so it is allocated on the stack */
        typedef std::array<result_type, nWords> counter_type;

    private:

        /*! \brief Create counter array from initializer list.
         *
         *  \param il  Initializer list object. This should either be empty
         *             or of the same length as the counter type, which is specified
         *             by the class template.
         *  \return    Counter array.
         *
         *  \throws    APIError if the initializer list is neither empty nor
         *             matches the size of the counter (i.e., words in the random engine).
         *
         *  If the initializer list is empty the counter will be set to zero.
         *  To avoid mistakes trying to initialize a 4x64 engine with two values
         *  or a 2x64 engine with four, we do not allow finite initializer
         *  lists that do not match the counter size.
         */
        counter_type
        makeCounterFromInitializerList(const std::initializer_list<result_type> &il)
        {
            counter_type ctr = {}; // make sure all elements are initialized

            if (il.size() > 0 && il.size() != ctr.size() )
            {
                GMX_THROW(APIError("Initializer list must match random engine word size, or be empty."));
            }

            std::copy(il.begin(), il.end(), ctr.begin());

            return ctr;
        }

        /*! \brief Clear highBits higest bits of ctr, return false if they were non-zero.
         *
         *  This function clears the space required for the internal counters,
         *  and returns true if they were correctly zero when calling, false otherwise.
         *
         *  \tparam        highBits  Number of bits to check. The template parameter makes it
         *                           possible to optimize this extensively at compile time.
         *  \param         ctr       Reference to counter to check and clear.
         */
        template<unsigned int highBits>
        bool
        checkAndClearHighBits(counter_type &ctr)
        {
            static_assert(highBits <= c_bitsTotal_, "High bits does not fit in counter.");

            const unsigned int lastWord       = (c_bitsTotal_ - highBits) / c_bitsPerWord_;
            const unsigned int lastWordLowBit = (c_bitsTotal_ - highBits) % c_bitsPerWord_;
            const result_type  lastWordOne    = static_cast<result_type>(1) << lastWordLowBit;
            const result_type  mask           = lastWordOne-1;

            bool               isClear = true;

            for (unsigned int i = nWords-1; i > lastWord; --i)
            {
                if (ctr[i])
                {
                    isClear = false;
                    ctr[i]  = 0;
                }
            }
            if (highBits > 0 && ctr[lastWord] >= lastWordOne)
            {
                isClear        = false;
                ctr[lastWord] &= mask;
            }
            return isClear;
        }

        /*! \brief Increment the internal counter in highBits by one
         *
         *  \tparam         highBits  Number of bits reserved for the internal counter.
         *  \param          ctr       Reference to the counter value to increment.
         *
         *  \throws InternalError if internal counter space is exhausted.
         *
         *  This routine will work across the word boundaries for any number
         *  of internal counter bits that fits in the total counter.
         */
        template<unsigned int highBits>
        void
        incrementHighBits(counter_type &ctr)
        {
            static_assert(highBits <= c_bitsTotal_, "High bits does not fit in counter.");

            const unsigned int lastWordIdx       = (c_bitsTotal_ - highBits) / c_bitsPerWord_;
            const unsigned int lastWordLowBitIdx = (c_bitsTotal_ - highBits) % c_bitsPerWord_;
            const result_type  lastWordOne       = static_cast<result_type>(1) << lastWordLowBitIdx;

            // For algorithm & efficiency reasons we need to store the internal counter in
            // the same array as the user-provided counter, so we use the higest bits, possibly
            // crossing several words.
            //
            // To have the computer help us with the dirty carry arithmetics we store the bits
            // in the internal counter part in normal fashion, but the internal counter words in
            // reverse order; the highest word of the total counter array (nWords-1) is thus
            // the least significant part of the internal counter (if it spans several words).
            //
            // The incrementation works as follows:
            //
            // 0) If the index of the least significant internal counter word is larger
            //    than nWords-1, there was never any space.
            // 1) If the internal counter spans more than one word, we must have one or
            //    more internal counter words that correspond entirely to the this counter.
            //    Start with the least significant one (nWords-1) and increment it.
            //    If the new value is not zero we did not loop around (no carry), so everything
            //    is good, and we are done - return!
            //    If the new value is zero, we need to move the carry result to the next word,
            //    so we just continue the loop until we have gone through all words that
            //    are internal-counter-only.
            // 2) After the loop, there is stuff remaining to add, and by definition there
            //    is some internal counter space in the next word, but the question
            //    is if we have exhausted it. We already created a constant that corresponds
            //    to the bit that represents '1' for the internal counter part of this word.
            //    When we add this constant it will not affect the user-counter-part at all,
            //    and if we exhaust the internal counter space the high bits will cause the entire
            //    word to wrap around, and the result will be smaller than the bit we added.
            //    If this happens we throw, otherwise we're done.
            //
            // Since all constants will be evaluated at compile time, this entire routine
            // will usually be reduced to simply incrementing a word by a constant, and throwing
            // if the result is smaller than the constant.

            if (lastWordIdx >= nWords)
            {
                GMX_THROW(InternalError("Cannot increment ThreeFry64 random engine defined with 0 internal counter bits."));
            }

            for (unsigned int i = nWords-1; i > lastWordIdx; --i)
            {
                ctr[i]++;
                if (ctr[i])
                {
                    // No carry means we are done
                    return;
                }
            }

            ctr[lastWordIdx] += lastWordOne;
            if (ctr[lastWordIdx] < lastWordOne)
            {
                GMX_THROW(InternalError("ThreeFry64 random engine stream ran out of internal counter space."));
            }
            return;
        }

        /*! \brief Increment the internal counter in highBits by a value.
         *
         *  \tparam        highBits  Number of bits reserved for the internal counter.
         *  \param         ctr       Reference to the counter to increment.
         *  \param         addend    Value to add to internal.
         *
         *  \throws InternalError if internal counter space is exhausted.
         *
         *  This routine will work across the word boundaries for any number
         *  of internal counter bits that fits in the total counter.
         */
        template<unsigned int highBits>
        void
        incrementHighBits(counter_type &ctr, result_type addend)
        {
            static_assert(highBits <= c_bitsTotal_, "High bits must fit in counter");

            const unsigned int lastWordIdx       = (c_bitsTotal_ - highBits) / c_bitsPerWord_;
            const unsigned int lastWordLowBitIdx = (c_bitsTotal_ - highBits) % c_bitsPerWord_;
            const result_type  lastWordOne       = static_cast<result_type>(1) << lastWordLowBitIdx;
            const result_type  lastWordMaxVal    = (~static_cast<result_type>(0)) >> lastWordLowBitIdx;

            if (lastWordIdx >= nWords)
            {
                GMX_THROW(InternalError("Cannot increment ThreeFry64 random engine defined with 0 internal counter bits."));
            }

            for (unsigned int i = nWords-1; i > lastWordIdx; --i)
            {
                ctr[i] += addend;
                addend  = (ctr[i] < addend);  // 1 is the carry!
                if (addend == 0)
                {
                    return;
                }
            }

            if (addend > lastWordMaxVal)
            {
                GMX_THROW(InternalError("A ThreeFry64 random engine stream ran out of internal counter space."));
            }
            addend *= lastWordOne;

            ctr[lastWordIdx] += addend;

            if (ctr[lastWordIdx] < addend)
            {
                GMX_THROW(InternalError("B ThreeFry64 random engine stream ran out of internal counter space."));
            }
            return;
        }

        /*! \brief Silently set high key bits to avoid overlaps.
         *
         *  \param key Reference to key value where high bits should be initialized
         *
         *  To avoid unintentional overlapping streams between counters, we set
         *  the highest bits of the key to the encode the value of internalCounterBits.
         *  This will make sure all engines that are not identical also produce
         *  different streams of random numbers.
         *
         *  Nonzero high bits are merely cleared silently. This is useful to be
         *  able to seed with keys from another random source where you
         *  do not control the higest bits, but also do not care about their value.
         */
        void
        initHighKeyBits(counter_type &key)
        {
            if (internalCounterBits > 0)
            {
                checkAndClearHighBits<c_internalCounterBitsBits_>(key);
                incrementHighBits<c_internalCounterBitsBits_>(key, internalCounterBits);
            }
        }

        /*! \brief Rotate value left by specified number of bits
         *
         *  \param i    Value to rotate (result_type, which should be 64-bit).
         *  \param bits Number of bits to rotate i.
         *
         *  \return Input value rotated 'bits' left.
         */
        result_type
        rotLeft(result_type i, unsigned int bits)
        {
            return (i << bits) | (i >> (c_bitsPerWord_-bits));
        }

        /*! \brief Perform encryption step for ThreeFry2x64 algorithm
         *
         *  This method should only be called when the class parameter nWords==2.
         *
         *  It performs the encryption step of the standard ThreeFish symmetric-key
         *  tweakable block cipher, which is the core of the ThreeFry random
         *  engine. The number of encryption rounds is specified by the class
         *  template parameter 'rounds'.
         *
         *  \param key   Reference to key value
         *  \param ctr   Counter value to use
         *
         *  \return Newly encrypted 2x64 block, according to the class template parameters.
         */
        std::array<result_type, 2>
        generateBlock(const std::array<result_type, 2> &key,
                      const std::array<result_type, 2> &ctr)
        {
            const unsigned int         rotations[] = {16, 42, 12, 31, 16, 32, 24, 21};
            std::array<result_type, 2> x;

            result_type                ks[3];

            ks[2] = 0x1bd11bdaa9fc1a22;

            ks[0] = key[0]; ks[2] ^= key[0]; x[0] = ctr[0] + key[0];
            ks[1] = key[1]; ks[2] ^= key[1]; x[1] = ctr[1] + key[1];

            // This is actually a pretty simple routine that merely executes the
            // for-block specified further down 'rounds' times. However, both
            // clang and gcc have problems unrolling and replacing rotations[r%8]
            // with constants, so we unroll the first 20 iterations manually.
            x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0];
            if (rounds == 1)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 42); x[1] ^= x[0];
            if (rounds == 2)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[0];
            if (rounds == 3)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 31); x[1] ^= x[0]; x[0] += ks[1]; x[1] += ks[2] + 1;
            if (rounds == 4)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0];
            if (rounds == 5)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 32); x[1] ^= x[0];
            if (rounds == 6)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 24); x[1] ^= x[0];
            if (rounds == 7)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 21); x[1] ^= x[0]; x[0] += ks[2]; x[1] += ks[0] + 2;
            if (rounds == 8)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0];
            if (rounds == 9)  { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 42); x[1] ^= x[0];
            if (rounds == 10) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[0];
            if (rounds == 11) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 31); x[1] ^= x[0]; x[0] += ks[0]; x[1] += ks[1] + 3;
            if (rounds == 12) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0];
            if (rounds == 13) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 32); x[1] ^= x[0];
            if (rounds == 14) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 24); x[1] ^= x[0];
            if (rounds == 15) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 21); x[1] ^= x[0]; x[0] += ks[1]; x[1] += ks[2] + 4;
            if (rounds == 16) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 16); x[1] ^= x[0];
            if (rounds == 17) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 42); x[1] ^= x[0];
            if (rounds == 18) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[0];
            if (rounds == 19) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 31); x[1] ^= x[0]; x[0] += ks[2]; x[1] += ks[0] + 5;
            if (rounds == 20) { return x; }

            for (unsigned int r = 20; r < rounds; r++)
            {
                x[0] += x[1];
                x[1]  = rotLeft(x[1], rotations[r%8]);
                x[1] ^= x[0];
                if (( (r + 1) & 3 ) == 0)
                {
                    unsigned int r4 = (r + 1) >> 2;
                    x[0] += ks[ r4 % 3 ];
                    x[1] += ks[ (r4 + 1) % 3 ] + r4;
                }
            }
            return x;
        }

        /*! \brief Perform encryption step for ThreeFry4x64 algorithm
         *
         *  This method should only be called when the class parameter nWords==4.
         *
         *  It performs the encryption step of the standard ThreeFish symmetric-key
         *  tweakable block cipher, which is the core of the ThreeFry random
         *  engine. The number of encryption rounds is specified by the class
         *  template parameter 'rounds'.
         *
         *  \param key   Reference to key value
         *  \param ctr   Counter value to use
         *
         *  \return Newly encrypted 4x64 block.
         */
        std::array<result_type, 4>
        generateBlock(const std::array<result_type, 4> &key,
                      const std::array<result_type, 4> &ctr)
        {
            const unsigned int         rotations0[] = {14, 52, 23,  5, 25, 46, 58, 32};
            const unsigned int         rotations1[] = {16, 57, 40, 37, 33, 12, 22, 32};
            std::array<result_type, 4> x;

            gmx_uint64_t               ks[5];

            ks[4] = 0x1bd11bdaa9fc1a22;

            ks[0] = key[0]; ks[4] ^= key[0]; x[0] = ctr[0] + key[0];
            ks[1] = key[1]; ks[4] ^= key[1]; x[1] = ctr[1] + key[1];
            ks[2] = key[2]; ks[4] ^= key[2]; x[2] = ctr[2] + key[2];
            ks[3] = key[3]; ks[4] ^= key[3]; x[3] = ctr[3] + key[3];

            // This is actually a pretty simple routine that merely executes the
            // for-block specified further down 'rounds' times. However, both
            // clang and gcc have problems unrolling and replacing rotations[r%8]
            // with constants, so we unroll the first 20 iterations manually.
            x[0] += x[1]; x[1] = rotLeft(x[1], 14); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 16); x[3] ^= x[2];
            if (rounds == 1) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 52); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 57); x[1] ^= x[2];
            if (rounds == 2) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 23); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 40); x[3] ^= x[2];
            if (rounds == 3) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 5); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 37); x[1] ^= x[2];
            x[0] += ks[1]; x[1] += ks[2]; x[2] += ks[3]; x[3] += ks[4] + 1;
            if (rounds == 4) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 25); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 33); x[3] ^= x[2];
            if (rounds == 5) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 46); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[2];
            if (rounds == 6) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 58); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 22); x[3] ^= x[2];
            if (rounds == 7) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 32); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 32); x[1] ^= x[2];
            x[0] += ks[2]; x[1] += ks[3]; x[2] += ks[4]; x[3] += ks[0] + 2;
            if (rounds == 8) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 14); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 16); x[3] ^= x[2];
            if (rounds == 9) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 52); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 57); x[1] ^= x[2];
            if (rounds == 10) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 23); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 40); x[3] ^= x[2];
            if (rounds == 11) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 5); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 37); x[1] ^= x[2];
            x[0] += ks[3]; x[1] += ks[4]; x[2] += ks[0]; x[3] += ks[1] + 3;
            if (rounds == 12) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 25); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 33); x[3] ^= x[2];
            if (rounds == 13) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 46); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 12); x[1] ^= x[2];
            if (rounds == 14) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 58); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 22); x[3] ^= x[2];
            if (rounds == 15) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 32); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 32); x[1] ^= x[2];
            x[0] += ks[4]; x[1] += ks[0]; x[2] += ks[1]; x[3] += ks[2] + 4;
            if (rounds == 16) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 14); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 16); x[3] ^= x[2];
            if (rounds == 17) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 52); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 57); x[1] ^= x[2];
            if (rounds == 18) { return x; }
            x[0] += x[1]; x[1] = rotLeft(x[1], 23); x[1] ^= x[0];
            x[2] += x[3]; x[3] = rotLeft(x[3], 40); x[3] ^= x[2];
            if (rounds == 19) { return x; }
            x[0] += x[3]; x[3] = rotLeft(x[3], 5); x[3] ^= x[0];
            x[2] += x[1]; x[1] = rotLeft(x[1], 37); x[1] ^= x[2];
            x[0] += ks[0]; x[1] += ks[1]; x[2] += ks[2]; x[3] += ks[3] + 5;
            if (rounds == 20) { return x; }

            for (unsigned int r = 20; r < rounds; r++)
            {
                if ((r&1) == 0)
                {
                    x[0] += x[1]; x[1] = rotLeft(x[1], rotations0[r%8]); x[1] ^= x[0];
                    x[2] += x[3]; x[3] = rotLeft(x[3], rotations1[r%8]); x[3] ^= x[2];
                }
                else
                {
                    x[0] += x[3]; x[3] = rotLeft(x[3], rotations0[r%8]); x[3] ^= x[0];
                    x[2] += x[1]; x[1] = rotLeft(x[1], rotations1[r%8]); x[1] ^= x[2];
                }
                if (( (r + 1) & 3 ) == 0)
                {
                    unsigned int r4 = (r + 1) >> 2;
                    x[0] += ks[ (r4 + 0) % 5 ];
                    x[1] += ks[ (r4 + 1) % 5 ];
                    x[2] += ks[ (r4 + 2) % 5 ];
                    x[3] += ks[ (r4 + 3) % 5 ] + r4;
                }
            }
            return x;
        }

    public:
        //! \brief Smallest value that can be returned from random engine.
        static constexpr result_type min() { return std::numeric_limits<result_type>::min(); }

        //! \brief Largest value that can be returned from random engine.
        static constexpr result_type max() { return std::numeric_limits<result_type>::max(); }

        /*! \brief Construct random engine with key from counter array
         *
         *  \param key Array with random seeds. This should be of length 2 for
         *             ThreeFry2x64, and length 4 when calling ThreeFry4x64.
         *             The first value is the lowest word of the key, and the last
         *             value the highest. Note that the highest few bits of the last
         *             word are reserved to encode the number of internal counter
         *             bits (i.e., 12 internal counter bits means the 4 highest
         *             key bits encode that value).
         *
         *  \throws InternalError if the highest few bits of the key are non-zero.
         */
        ThreeFry64(const counter_type &key)
        {
            seed(key);
        }

        /*! \brief Construct random engine with key from initializer list
         *
         *  \param il Initializer list with random seeds. This should
         *            be of length 2 for ThreeFry2x64, and length 4 when calling
         *            ThreeFry4x64, or it can be empty - in which case the key is
         *            set to zero. The first value is the lowest word of the key,
         *            and the last value the highest. Note that the highest few bits
         *            of the last word are reserved to encode the number of internal
         *            counter bits (i.e., 12 internal counter bits means the 4 highest
         *            key bits encode that value).
         */
        ThreeFry64(const std::initializer_list<result_type> &il = {}
                   )
        {
            seed(il);
        }

        /*! \brief Seed random engine with key from counter array
         *
         *  \param key Re-initialized the seed similar to the counter constructor.
         *             Same rules apply: The highest few bits of the last word are
         *             reserved to encode the number of internal counter bits, but
         *             to save the user the trouble of making sure these are zero
         *             when using e.g. a random device, we just ignore them.
         */
        void
        seed(const counter_type &key)
        {
            key_ = key;
            initHighKeyBits(key_);
            restart();
        }

        /*! \brief Seed random engine with key from initializer list
         *
         *  \param il  Re-initialized the seed similar to the initializer-list
         *             constructor. Same rules apply: The highest few bits of the
         *             last word are reserved to encode the number of internal
         *             counter bits.
         *
         *  \throws InternalError if the highest few bits of the key are non-zero.
         */
        void
        seed(const std::initializer_list<result_type> &il)
        {
            seed(makeCounterFromInitializerList(il));
        }

        /*! \brief Restart random engine counter from counter
         *
         * \param  ctr New counter value.
         *
         * Restarting the engine with a new counter is extremely fast with ThreeFry64,
         * and basically just consists of storing the counter value, so you should
         * use this liberally in your innermost loops to restart the engine with
         * e.g. the current step and atom index as counter values.
         *
         * \throws InternalError if any of the highest bits that are reserved
         *         for the internal part of the counter are set. The number of
         *         reserved bits is to the last template parameter to the class.
         */
        void
        restart(const counter_type &ctr)
        {
            counter_ = ctr;
            if (!checkAndClearHighBits<c_internalCounterBitsBits_>(counter_))
            {
                GMX_THROW(InternalError("High bits of counter are reserved for the internal stream counter."));
            }
            block_ = generateBlock(key_, counter_);
            index_ = 0;
        }

        /*! \brief Restart random engine counter from initializer list
         *
         * \param  il Initializer list with the new counter values.
         *
         * Restarting the engine with a new counter is extremely fast with ThreeFry64,
         * and basically just consists of storing the counter value, so you should
         * use this liberally in your innermost loops to restart the engine with
         * e.g. the current step and atom index as counter values.
         *
         * \throws InternalError if any of the highest bits that are reserved
         *         for the internal part of the counter are set. The number of
         *         reserved bits is to the last template parameter to the class.
         */
        void
        restart(const std::initializer_list<result_type> il = {})
        {
            restart(makeCounterFromInitializerList(il));
        }

        /*! \brief Generate the next random number
         *
         *  This will return the next stored 64-bit value if one is available,
         *  and otherwise generate a new block, update the internal counters, and
         *  return the first value while storing the others.
         *
         *  \throws InternalError if the internal counter space is exhausted.
         */
        result_type
        operator()()
        {
            if (index_ >= c_resultsPerCounter_)
            {
                incrementHighBits<internalCounterBits>(counter_);
                block_ = generateBlock(key_, counter_);
                index_ = 0;
            }
            return block_[index_++];
        }

        /*! \brief Skip next n random numbers
         *
         *  Moves the internal random stream for the give key/counter value
         *  n positions forward. The count is based on the number of random values
         *  returned, such that skipping 5 values gives exactly the same result as
         *  drawing 5 values that are ignored.
         *
         *  \param n Number of values to jump forward.
         *
         *  \throws InternalError if the internal counter space is exhausted.
         */
        void
        discard(gmx_uint64_t n)
        {
            index_ += n % c_resultsPerCounter_;
            n      /= c_resultsPerCounter_;

            if (index_ > c_resultsPerCounter_)
            {
                index_ -= c_resultsPerCounter_;
                n++;
            }

            // Make sure the state is the same as if we came to this counter and
            // index by natural generation.
            if (index_ == 0 && n > 0)
            {
                index_ = c_resultsPerCounter_;
                n--;
            }
            incrementHighBits<internalCounterBits>(counter_, n);
            block_ = generateBlock(key_, counter_);
        }

        template<unsigned int nw, unsigned int r, unsigned int icb>
        friend bool
        operator==(const ThreeFry64<nw, r, icb> &x, const ThreeFry64<nw, r, icb> &y);

        template<unsigned int nw, unsigned int r, unsigned int icb>
        friend bool
        operator!=(const ThreeFry64<nw, r, icb> &x, const ThreeFry64<nw, r, icb> &y);

        template<class CharT, class Traits,
                 unsigned int nw, unsigned int r, unsigned int icb>
        friend std::basic_ostream<CharT, Traits> &
        operator<<(std::basic_ostream<CharT, Traits> &os, const ThreeFry64<nw, r, icb> &x);

        template<class CharT, class Traits,
                 unsigned int nw, unsigned int r, unsigned int icb>
        friend std::basic_istream<CharT, Traits> &
        operator>>(std::basic_istream<CharT, Traits> &is, ThreeFry64<nw, r, icb> &x);

    private:

        static const unsigned int c_internalCounterBitsBits_ = (internalCounterBits > 0) ? ( StaticLog2<internalCounterBits>::value + 1 ) : 0;
        static const unsigned int c_bitsPerWord_             = std::numeric_limits<gmx_uint64_t>::digits;
        static const unsigned int c_bitsTotal_               = c_bitsPerWord_ * nWords;
        static const unsigned int c_resultsPerCounter_       = static_cast<unsigned int>(sizeof(counter_type)/sizeof(result_type));

        /*! \brief ThreeFry64 key, i.e. the random seed for this stream.
         *
         *  The highest few bits of the key are reserved to encode the value of
         *  internalCounterBits, in order to make all streams unique.
         */
        counter_type key_;

        /*! \brief ThreeFry64 total counter.
         *
         *  The highest internalCounterBits are reserved for an internal counter
         *  so that the combination of a key and counter provides a stream that
         *  returns 2*2^internalCounterBits (ThreeFry2x64) or
         *  4*2^internalCounterBits (ThreeFry4x64) random 64-bit values before the
         *  internal counter space is exhausted and an exception is thrown.
         */
        counter_type counter_;
        /*! \brief The present block encrypted from values of key and counter. */
        counter_type block_;
        /*! \brief Index of the next value in block_ to return from random engine */
        unsigned int index_;
};


/*! \brief Return true of two ThreeFry64 engines are identical
 *
 * \tparam nw   Number of words in ThreeFry64 engine
 * \tparam r    Rounds of encryption in ThreeFry64 engine
 * \tparam icb  Number of internal counter bits reserved in ThreeFry64 engine
 *
 * \param  x    First comparand ThreeFry64 random engine.
 * \param  y    Second comparand ThreeFry64 random engine.
 *
 * This routine should return true if the two engines will generate
 * identical random streams when drawing.
 */
template<unsigned int nw, unsigned int r, unsigned int icb>
bool
operator==(const ThreeFry64<nw, r, icb> &x, const ThreeFry64<nw, r, icb> &y)
{
    // block_ is uniquely specified by key_ and counter_.
    return (x.key_ == y.key_ &&
            x.counter_ == y.counter_ &&
            x.index_ == y.index_);
}

/*! \brief Return true of two ThreeFry64 engines are not identical
 *
 * \tparam nw   Number of words in ThreeFry64 engine
 * \tparam r    Rounds of encryption in ThreeFry64 engine
 * \tparam icb  Number of internal counter bits reserved in ThreeFry64 engine
 *
 * \param  x    First comparand ThreeFry64 random engine.
 * \param  y    Second comparand ThreeFry64 random engine.
 *
 * This routine should return true if the two engines will generate
 * different random streams when drawing.
 */
template<unsigned int nw, unsigned int r, unsigned int icb>
bool
operator!=(const ThreeFry64<nw, r, icb> &x, const ThreeFry64<nw, r, icb> &y)
{
    return !(x == y);
}

/*! \brief Write ThreeFry64 random engine state to output stream.
 *
 * \tparam CharT   Character type of stream to write to
 * \tparam Traits  Character traits of stream to write to
 * \tparam nw      Number of words in ThreeFry64 engine
 * \tparam r       Rounds of encryption in ThreeFry64 engine
 * \tparam icb     Number of internal counter bits reserved in ThreeFry64 engine
 *
 * \param  os      Output stream to write present state to. The output should
 *                 be sufficient to restore the engine at a later point and
 *                 then generate an identical random stream.
 * \param  x       ThreeFry64 random engine being written.
 *
 * This routine should return true if the two engines will generate
 * identical random streams when drawing.
 */
template<class CharT, class Traits, unsigned int nw, unsigned int r, unsigned int icb>
std::basic_ostream<CharT, Traits> &
operator<<(std::basic_ostream<CharT, Traits> &os,
           const ThreeFry64<nw, r, icb> &x)
{
    std::ios_base::fmtflags savedFlags = os.flags(std::ios_base::dec | std::ios_base::left);

    CharT                   sp = os.widen(' ');
    os.fill(sp);

    for (unsigned int i = 0; i < nw; i++)
    {
        os << sp << x.key_[i];
    }
    for (unsigned int i = 0; i < nw; i++)
    {
        os << sp << x.counter_[i];
    }
    os << sp << x.index_;

    os.flags(savedFlags);
    return os;
}

/*! \brief Read ThreeFry64 random engine state from. input stream.
 *
 * \tparam CharT   Character type of stream to read from
 * \tparam Traits  Character traits of stream to read from
 * \tparam nw      Number of words in ThreeFry64 engine
 * \tparam r       Rounds of encryption in ThreeFry64 engine
 * \tparam icb     Number of internal counter bits reserved in ThreeFry64 engine
 *
 * \param is       Input stream to read present state from. The same fields
 *                 as written from the corresponding output routine will be
 *                 read.
 * \param x        ThreeFry64 random engine being restored.
 *
 * This routine should return true if the two engines will generate
 * identical random streams when drawing.
 */
template<class CharT, class Traits, unsigned int nw, unsigned int r, unsigned int icb>
std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           ThreeFry64<nw, r, icb> &x)
{
    std::ios_base::fmtflags savedFlags = is.flags(std::ios_base::dec | std::ios_base::skipws);

    for (unsigned int i = 0; i < nw; i++)
    {
        is >> x.key_[i];
    }
    for (unsigned int i = 0; i < nw; i++)
    {
        is >> x.counter_[i];
    }
    x.block_ = x.generateBlock(x.key_, x.counter_);
    is >> x.index_;

    is.flags(savedFlags);
    return is;
}

/*! \brief ThreeFry2x64 random engine with 20 iteractions.
 *
 *  \tparam internalCounterBits, default 64.
 *
 *  This class provides very high quality random numbers that pass all
 *  BigCrush tests, it works with two 64-bit values each for keys and
 *  counters, and is most  efficient when we only need a few random values
 *  before restarting the counters with new values.
 */
template<unsigned int internalCounterBits = 64>
using ThreeFry2x64 = ThreeFry64<2, 20, internalCounterBits>;

/*! \brief ThreeFry2x64 random engine with 13 iteractions.
 *
 *  \tparam internalCounterBits, default 64.
 *
 *  This class provides relatively high quality random numbers that only
 *  fail one BigCrush test, and it is a bit faster than the 20-round version.
 *  It works with two 64-bit values each for keys and counters, and is most
 *  efficient when we only need a few random values before restarting
 *  the counters with new values.
 */
template<unsigned int internalCounterBits = 64>
using ThreeFry2x64Fast                    = ThreeFry64<2, 13, internalCounterBits>;

/*! \brief ThreeFry4x64 random engine with 20 iteractions.
 *
 *  \tparam internalCounterBits, default 64.
 *
 *  This class provides very high quality random numbers that pass all
 *  BigCrush tests, it works with four 64-bit values each for keys and
 *  counters, and is most efficient when a large amount of random numbers
 *  are drawn before restarting counters.
 */
template<unsigned int internalCounterBits = 64>
using ThreeFry4x64 = ThreeFry64<4, 20, internalCounterBits>;

/*! \brief ThreeFry4x64 random engine with 13 iteractions.
 *
 *  \tparam internalCounterBits, default 64.
 *
 *  This class provides relatively high quality random numbers that only
 *  fail one BigCrush test, and it is a bit faster than the 20-round version.
 *  It works with two 64-bit values each for keys and counters, and is most
 *  efficient when a large amount of random numbers are drawn before
 *  restarting counters.
 */
template<unsigned int internalCounterBits = 64>
using ThreeFry4x64Fast                    = ThreeFry64<4, 13, internalCounterBits>;


/*! \brief Tabulated normal random distribution
 *
 *  Random distribution compatible with C++11 distributions - it can be
 *  used with any C++11 random engine.
 *
 *  \tparam RealType  Type of the return value. Float or double. Note that
 *                    GROMACS uses "real" type by default in contrast to the C++11
 *                    standard library, to avoid double/float conversions.
 *  \tparam tableBits Size of the table, specified in bits. The storage
 *                    space required is sizeof(RealType)*2^tableBits. To
 *                    keep things sane this is limited to 24 bits.
 *
 *  Some stochastic integrators depend on drawing a lot of normal
 *  distribution random numbers quickly, but in many cases the only
 *  important property is the distribution - given the noise in forces
 *  we do not need very high resolution.
 *  This distribution uses an internal table to return samples from a
 *  normal distribution with limited resolution. By default the table uses
 *  14 bits, but this is specified with a template parameter.
 *
 *  Since this distribution only uses tableBits bits per value generated,
 *  the values draw from the random engine are used for several results.
 *  To make sure you get a reproducible result when using counter-based
 *  random engines (such as ThreeFry64), remember to call the reset()
 *  method to cancel the internal memory of the distribution.
 *
 *  \note For modern NUMA systems, you likely want to use separate
 *        distributions for each thread, and make sure they are initialized
 *        on the CPU where they will run, so the table is placed in that
 *        NUMA memory pool.
 *  \note The finite table resolution means this distribution will NOT
 *        return arbitrarily small/large values, but with e.g. 14 bits
 *        the results are limited to roughly +/- 4 standard deviations.
 */
template<class RealType = real, unsigned int tableBits = 14>
class TabulatedNormalDistribution
{
    static_assert(tableBits <= 24, "Normal distribution table is limited to 24bits (64MB in single precision)");

    public:
        /*! \brief  Type of normal distribution results */
        typedef RealType result_type;

        /*! \brief  Normal distribution parameter class (mean and stddev) */
        class param_type
        {
            public:
                /*! \brief The type of distribution the parameters describe */
                typedef TabulatedNormalDistribution distribution_type;

                /*! \brief Constructor. Default is classical distr. with mean 0, stddev 1.
                 *
                 * \param mean     Expectation value.
                 * \param stddev   Standard deviation.
                 *
                 */
                explicit param_type(result_type mean = 0.0, result_type stddev = 1.0)
                    : mean_(mean), stddev_(stddev) {}

                /*! \brief Return mean parameter of normal distribution */
                result_type
                mean() const {return mean_; }

                /*! \brief Return standard deviation parameter of normal distribution */
                result_type
                stddev() const {return stddev_; }

                /*! \brief True if two sets of normal distributions parameters are identical
                 *
                 * \param x First comparand
                 * \param y Second comparand
                 */
                friend
                bool operator==(const param_type &x, const param_type &y)
                {
                    return (x.mean_ == y.mean_ && x.stddev_ == y.stddev_);
                }

                /*! \brief True if two sets of normal distributions parameters are different.
                 *
                 * \param x First comparand
                 * \param y Second comparand
                 */
                friend
                bool operator!=(const param_type &x, const param_type &y)
                {
                    return !(x == y);
                }

            private:
                /*! \brief Internal storage for mean of normal distribution */
                result_type mean_;
                /*! \brief Internal storage for standard deviation of normal distribution */
                result_type stddev_;
        };

    private:

        /*! \brief Fill the table with values for the normal distribution
         *
         *  This routine returns a new reference to a std::vector allocated on
         *  the heap. It will only be called to generate the static
         *  constant table data at initialization time. While it is technically
         *  returning memory on the heap, this does not use/leak more memory
         *  than what we would use by having the same table as a static member
         *  of the class.
         */
        static
        std::vector<RealType> &
        makeTable()
        {
            /* Fill the table with the integral of a gaussian distribution:
             */
            std::size_t            tableSize        = 1 << tableBits;
            std::size_t            halfSize         = (1 << tableBits)/2;
            double                 invSize          = 1.0/tableSize;
            double                 factor           = std::sqrt(2.0*M_PI);
            double                 x                = 0.5*factor*invSize;

            std::vector<RealType>* table  = new std::vector<RealType>(1ULL << tableBits);

            for (std::size_t i = 0; i < halfSize; i++)
            {
                if (i > 0)
                {
                    double dx;

                    if (i < halfSize-1)
                    {
                        double invNormal = factor*std::exp(0.5*x*x);
                        /* det is larger than 0 for all x, except the last */
                        double det = 1.0 - 2.0*invSize*x*invNormal;
                        dx = (1 - std::sqrt(det))/x;
                    }
                    else
                    {
                        dx = 1.0/x;
                    }
                    x = x + dx;
                }
                table->at(halfSize-1-i) = -x;
                table->at(halfSize+i)   =  x;
            }
            return *table;
        }

    public:

        /*! \brief Construct new normal distribution with specified mean & stdddev.
         *
         *  \param mean    Mean value of tabulated normal distribution
         *  \param stddev  Standard deviation of tabulated normal distribution
         */
        explicit TabulatedNormalDistribution(result_type mean = 0.0, result_type stddev = 1.0 )
            : param_(param_type(mean, stddev)), savedRandomBits_(0), savedRandomBitsLeft_(0)
        {
            //   std::call_once(tableInitFlag_,fillNormalDistributionTable(),this);
        }

        /*! \brief Construct new normal distribution from parameter type.
         *
         *  \param param Parameter class containing mean and standard deviation.
         */
        explicit TabulatedNormalDistribution(  const param_type &param )
            : param_(param), savedRandomBits_(0), savedRandomBitsLeft_(0)
        {
            //   std::call_once(tableInitFlag_,fillNormalDistributionTable(),this);
        }

        /*! \brief Smallest value that can be generated in normal distrubiton.
         *
         * \note The smallest value is not -infinity with a table, but it
         *       depends on the table resolution. With 14 bits, this is roughly
         *       four standard deviations below the mean.
         */
        result_type
        min() const
        {
            return c_table_[0];
        }

        /*! \brief Largest value that can be generated in normal distribution.
         *
         * \note The largest value is not infinity with a table, but it
         *       depends on the table resolution. With 14 bits, this is roughly
         *       four standard deviations above the mean.
         */
        result_type
        max() const
        {
            return c_table_[c_table_.size()-1];
        }

        /*! \brief Mean of the present normal distribution */
        result_type
        mean() const
        {
            return param_.mean();
        }

        /*! \brief Standard deviation of the present normal distribution */

        result_type
        stddev() const
        {
            return param_.stddev();
        }

        /*! \brief The parameter class (mean & stddev) of the normal distribution */
        param_type
        param() const
        {
            return param_;
        }

        /*! \brief Clear all internal saved random bits from the random engine */
        void
        reset()
        {
            savedRandomBitsLeft_ = 0;
        }

        /*! \brief Return normal distribution value specified by internal parameters.
         *
         * \tparam Rng   Random engine type used to provide uniform random bits.
         * \param  g     Random engine of class Rng. For normal GROMACS usage
         *               you likely want to use ThreeFry2x64.
         */
        template<class Rng>
        result_type
        operator()(Rng &g)
        {
            return (*this)(g, param_);
        }

        /*! \brief Return normal distribution value specified by given parameters
         *
         * \tparam Rng   Random engine type used to provide uniform random bits.
         * \param  g     Random engine of class Rng. For normal GROMACS usage
         *               you likely want to use ThreeFry2x64.
         * \param  param Parameters used to specify normal distribution.
         */
        template<class Rng>
        result_type
        operator()(Rng &g, const param_type &param)
        {
            if (savedRandomBitsLeft_ < tableBits)
            {
                // We do not know whether the generator g returns 64 or 32 bits,
                // since g is not known when we construct this class.
                // To keep things simple, we always draw one random number,
                // store it in our 64-bit value, and set the number of active bits.
                // For tableBits up to 16 this will be as efficient both with 32
                // and 64 bit random engines when drawing multiple numbers
                // (our default value is 14), It also avoids drawing multiple
                // 32-bit random numbres even if we just call this routine for a
                // single result.
                savedRandomBits_     = static_cast<gmx_uint64_t>(g());
                savedRandomBitsLeft_ = std::numeric_limits<typename Rng::result_type>::digits;
            }
            result_type value        = c_table_[savedRandomBits_ & ( (1ULL << tableBits) - 1 ) ];
            savedRandomBits_       >>= tableBits;
            savedRandomBitsLeft_    -= tableBits;
            return param.mean() + value * param.stddev();
        }

        template<class T, unsigned int bits>
        friend bool
        operator==(const TabulatedNormalDistribution<T, bits> &x, const TabulatedNormalDistribution<T, bits> &y);

        template<class T, unsigned int bits>
        friend bool
        operator!=(const TabulatedNormalDistribution<T, bits> &x, const TabulatedNormalDistribution<T, bits> &y);

        template<class CharT, class Traits, class T, unsigned int bits>
        friend std::basic_ostream<CharT, Traits> &
        operator<<(std::basic_ostream<CharT, Traits> &os, const TabulatedNormalDistribution<T, bits> &x);

        template<class CharT, class Traits, class T, unsigned int bits>
        friend std::basic_istream<CharT, Traits> &
        operator>>(std::basic_istream<CharT, Traits> &is, TabulatedNormalDistribution<T, bits> &x);

    private:
        /*! \brief Parameters of normal distribution (mean and stddev) */
        param_type                                                   param_;
        /*! \brief Array with tabluated values of normal distribution */
        static const std::vector<RealType>                           c_table_;
        /*! \brief Flag to make sure we initialize table once and only once */
        std::once_flag                                               tableInitFlag_;
        /*! \brief Saved output from random engine, shifted tableBits right each time */
        gmx_uint64_t                                                 savedRandomBits_;
        /*! \brief Number of valid bits remaining i savedRandomBits_ */
        unsigned int                                                 savedRandomBitsLeft_;
};


// Clang on OSX needs to see a declaration of the specialization before we
// say it is extern and should not be instantiated here.

template<>
const std::vector<real> TabulatedNormalDistribution<real, 14>::c_table_;

extern template const std::vector<real> TabulatedNormalDistribution<real, 14>::c_table_;


template<class RealType, unsigned int tableBits>
const std::vector<RealType> TabulatedNormalDistribution<RealType, tableBits>::c_table_ = TabulatedNormalDistribution<RealType, tableBits>::makeTable();


/*!\brief Check if two tabulated normal distributions have identical states.
 *
 * \tparam T     Real type used for tabulated normal distribution.
 * \tparam bits  Table resolution in tabulated normal distribution.
 * \param  x     First comparand tabulated normal distribution.
 * \param  y     Second comparand tabulated normal distribution.
 */
template<class T, unsigned int bits>
bool
operator==(const TabulatedNormalDistribution<T, bits> &x,
           const TabulatedNormalDistribution<T, bits> &y)
{
    return (x.param_ == y.param_ &&
            x.savedRandomBits_ == y.savedRandomBits_ &&
            x.savedRandomBitsLeft_ == y.savedRandomBitsLeft_);
}

/*!\brief Check if two tabulated normal distributions have different states.
 *
 * \tparam T     Real type used for tabulated normal distribution.
 * \tparam bits  Table resolution in tabulated normal distribution.
 * \param  x     First comparand tabulated normal distribution.
 * \param  y     Second comparand tabulated normal distribution.
 */
template<class T, unsigned int bits>
bool
operator!=(const TabulatedNormalDistribution<T, bits> &x,
           const TabulatedNormalDistribution<T, bits> &y)
{
    return !(x == y);
}

/*!\brief Insert tabulated normal distributions state into output stream.
 *
 * \tparam CharT   Character type of stream to write to.
 * \tparam Traits  Character traits of stream to write to.
 * \tparam T       Real type used for tabulated normal distribution results.
 * \tparam bits    Table resolution in tabulated normal distribution.
 *
 * \param os       Output stream to write present state to. The output should
 *                 be sufficient to restore the engine at a later point and
 *                 then generate identical values if we also save the RNG.
 * \param  x       Tabulated normal distribution being written.
 */
template<class CharT, class Traits, class T, unsigned int bits>
std::basic_ostream<CharT, Traits> &
operator<<(std::basic_ostream<CharT, Traits> &os,
           const TabulatedNormalDistribution<T, bits> &x)
{
    std::ios_base::fmtflags savedFlags = os.flags(std::ios_base::dec | std::ios_base::left);

    CharT                   sp = os.widen(' ');
    os.fill(sp);

    os << sp << x.mean();
    os << sp << x.stddev();
    os << sp << x.savedRandomBits_;
    os << sp << x.savedRandomBitsLeft_;

    os.flags(savedFlags);
    return os;
}

/*!\brief Load tabulated normal distributions state from input stream.
 *
 * \tparam CharT   Character type of stream to read from.
 * \tparam Traits  Character traits of stream to read from.
 * \tparam T       Real type used for tabulated normal distribution results.
 * \tparam bits    Table resolution in tabulated normal distribution.
 *
 * \param  is      Input stream to read present state from. The same fields
 *                 as written from the corresponding output routine will be
 *                 read.
 *  \param x       Tabulated normal distribution being restored from strea.
 */
template<class CharT, class Traits, class T, unsigned int bits>
std::basic_istream<CharT, Traits> &
operator>>(std::basic_istream<CharT, Traits> &is,
           TabulatedNormalDistribution<T, bits> &x)
{
    std::ios_base::fmtflags savedFlags = is.flags(std::ios_base::dec | std::ios_base::skipws);

    T  mean, stddev;

    is >> mean;
    is >> stddev;
    x.param_ = typename TabulatedNormalDistribution<T, bits>::param_type(mean, stddev);
    is >> x.savedRandomBits_;
    is >> x.savedRandomBitsLeft_;

    is.flags(savedFlags);
    return is;
}

}      // namespace gmx

#endif // GMX_MATH_RANDOM_H
