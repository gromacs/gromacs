/*
 * 
 *                This source code is part of
 * 
 *                 G   R   O   M   A   C   S
 * 
 *          GROningen MAchine for Chemical Simulations
 * 
 *                        VERSION 3.3.2
 * Written by David van der Spoel, Erik Lindahl, Berk Hess, and others.
 * Copyright (c) 1991-2000, University of Groningen, The Netherlands.
 * Copyright (c) 2001-2007, The GROMACS development team,
 * check out http://www.gromacs.org for more information.

 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * If you want to redistribute modifications, please consider that
 * scientific software is very special. Version control is crucial -
 * bugs must be traceable. We will be happy to consider code for
 * inclusion in the official distribution, but derived work must not
 * be called official GROMACS. Details are found in the README & COPYING
 * files - if they are missing, get the official version at www.gromacs.org.
 * 
 * To help us fund GROMACS development, we humbly ask that you cite
 * the papers on the package - you can find them in the top README file.
 * 
 * For more info, check our website at http://www.gromacs.org
 * 
 * And Hey:
 * Groningen Machine for Chemical Simulation
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <math.h>
#include <stdlib.h>

#include "sysstuff.h"
#include "string.h"
#include "typedefs.h"
#include "smalloc.h"
#include "macros.h"
#include "vec.h"
#include "xvgr.h"
#include "pbc.h"
#include "copyrite.h"
#include "futil.h"
#include "statutil.h"
#include "index.h"
#include "nsc.h"
#include "pdbio.h"
#include "confio.h"
#include "rmpbc.h"
#include "names.h"
#include "atomprop.h"
#include "physics.h"

#include <trajana.h>

typedef struct {
  atom_id  aa,ab;
  real     d2a,d2b;
} t_conect;

void add_rec(t_conect c[],atom_id i,atom_id j,real d2)
{
  if (c[i].aa == NO_ATID) {
    c[i].aa  = j;
    c[i].d2a = d2;
  }
  else if (c[i].ab == NO_ATID) {
    c[i].ab  = j;
    c[i].d2b = d2;
  }
  else if (d2 < c[i].d2a) {
    c[i].aa  = j;
    c[i].d2a = d2;
  }
  else if (d2 < c[i].d2b) {
    c[i].ab  = j;
    c[i].d2b = d2;
  }
  /* Swap them if necessary: a must be larger than b */
  if (c[i].d2a < c[i].d2b) {
    j        = c[i].ab;
    c[i].ab  = c[i].aa;
    c[i].aa  = j;
    d2       = c[i].d2b;
    c[i].d2b = c[i].d2a;
    c[i].d2a = d2;
  }
}

void do_conect(char *fn,int n,rvec x[])
{
  FILE     *fp;
  int      i,j;
  t_conect *c;
  rvec     dx;
  real     d2;
  
  fprintf(stderr,"Building CONECT records\n");
  snew(c,n);
  for(i=0; (i<n); i++) 
    c[i].aa = c[i].ab = NO_ATID;
  
  for(i=0; (i<n); i++) {
    for(j=i+1; (j<n); j++) {
      rvec_sub(x[i],x[j],dx);
      d2 = iprod(dx,dx);
      add_rec(c,i,j,d2);
      add_rec(c,j,i,d2);
    }
  }
  fp = ffopen(fn,"a");
  for(i=0; (i<n); i++) {
    if ((c[i].aa == NO_ATID) || (c[i].ab == NO_ATID))
      fprintf(stderr,"Warning dot %d has no conections\n",i+1);
    fprintf(fp,"CONECT%5d%5d%5d\n",i+1,c[i].aa+1,c[i].ab+1);
  }
  ffclose(fp);
  sfree(c);
}

void connelly_plot(char *fn,int ndots,real dots[],rvec x[],t_atoms *atoms,
		   t_symtab *symtab,int ePBC,matrix box,bool bSave)
{
  static const char *atomnm="DOT";
  static const char *resnm ="DOT";
  static const char *title ="Connely Dot Surface Generated by g_sas";

  int  i,i0,r0,ii0,k;
  rvec *xnew;
  t_atoms aaa;

  if (bSave) {  
    i0 = atoms->nr;
    r0 = atoms->nres;
    srenew(atoms->atom,atoms->nr+ndots);
    srenew(atoms->atomname,atoms->nr+ndots);
    srenew(atoms->resinfo,r0+1);
    atoms->atom[i0].resind = r0;
    t_atoms_set_resinfo(atoms,i0,symtab,resnm,r0+1,' ',' ');
    srenew(atoms->pdbinfo,atoms->nr+ndots);
    snew(xnew,atoms->nr+ndots);
    for(i=0; (i<atoms->nr); i++)
      copy_rvec(x[i],xnew[i]);
    for(i=k=0; (i<ndots); i++) {
      ii0 = i0+i;
      atoms->atomname[ii0] = put_symtab(symtab,atomnm);
      atoms->pdbinfo[ii0].type = epdbATOM;
      atoms->pdbinfo[ii0].atomnr= ii0;
      atoms->atom[ii0].resind = r0;
      xnew[ii0][XX] = dots[k++];
      xnew[ii0][YY] = dots[k++];
      xnew[ii0][ZZ] = dots[k++];
      atoms->pdbinfo[ii0].bfac  = 0.0;
      atoms->pdbinfo[ii0].occup = 0.0;
    }
    atoms->nr   = i0+ndots;
    atoms->nres = r0+1;
    write_sto_conf(fn,title,atoms,xnew,NULL,ePBC,box);
    atoms->nres = r0;
    atoms->nr   = i0;
  }
  else {
    init_t_atoms(&aaa,ndots,TRUE);
    aaa.atom[0].resind = 0;
    t_atoms_set_resinfo(&aaa,0,symtab,resnm,1,' ',' ');
    snew(xnew,ndots);
    for(i=k=0; (i<ndots); i++) {
      ii0 = i;
      aaa.atomname[ii0] = put_symtab(symtab,atomnm);
      aaa.pdbinfo[ii0].type = epdbATOM;
      aaa.pdbinfo[ii0].atomnr= ii0;
      aaa.atom[ii0].resind = 0;
      xnew[ii0][XX] = dots[k++];
      xnew[ii0][YY] = dots[k++];
      xnew[ii0][ZZ] = dots[k++];
      aaa.pdbinfo[ii0].bfac  = 0.0;
      aaa.pdbinfo[ii0].occup = 0.0;
    }
    aaa.nr = ndots;
    write_sto_conf(fn,title,&aaa,xnew,NULL,ePBC,box);
    do_conect(fn,ndots,xnew);
    free_t_atoms(&aaa,FALSE);
  }
  sfree(xnew);
}

real calc_radius(char *atom)
{
  real r;
  
  switch (atom[0]) {
  case 'C':
    r = 0.16;
    break;
  case 'O':
    r = 0.13;
    break;
  case 'N':
    r = 0.14;
    break;
  case 'S':
    r = 0.2;
    break;
  case 'H':
    r = 0.1;
    break;
  default:
    r = 1e-3;
  }
  return r;
}

typedef struct {
  int   ndots;
  bool  bResAt, bDGsol, bSave;
  bool  bFindex;
  char *fnConnelly;
  FILE **fp;
  FILE *vp;
  gmx_ana_selection_t *nwsel;
  gmx_ana_selection_t *fsel;

  real  totmass;
  bool *bPhobic;
  real *radius, *dgs_factor;
  real *atom_area, *atom_area2;
  real *res_a, *res_area, *res_area2;
} t_sasdata;

static int
analyze_frame(t_topology *top, t_trxframe *fr, t_pbc *pbc,
              int nr, gmx_ana_selection_t *sel[], void *data)
{
  t_sasdata   *d = (t_sasdata *)data;
  bool         bConnelly;
  bool         bPhobic;
  int          g,i,k,ii,flag,nsurfacedots;
  int          retval;
  real        *surfacedots, *area;
  real         totarea,totvolume,density,harea,tarea;
  real         at_area;
  real         dgsolv;

  surfacedots = NULL;
  area        = NULL;
  bConnelly = (d->fnConnelly != NULL);
  if (bConnelly)
    flag = FLAG_ATOM_AREA | FLAG_DOTS;
  else
    flag = FLAG_ATOM_AREA;
  if (d->vp)
    flag = flag | FLAG_VOLUME;

  if (debug)
    write_sto_conf("check.pdb","pbc check",&top->atoms,fr->x,NULL,fr->ePBC,fr->box);

  retval = nsc_dclm_pbc(fr->x,d->radius,d->nwsel->p.nr,d->ndots,flag,&totarea,
                        &area,&totvolume,&surfacedots,&nsurfacedots,
                        d->nwsel->g->index,fr->ePBC,pbc ? fr->box : NULL);
  if (retval)
    gmx_fatal(FARGS,"Something wrong in nsc_dclm2");

  if (bConnelly) {
    connelly_plot(d->fnConnelly,
                  nsurfacedots,surfacedots,fr->x,&top->atoms,
                  &(top->symtab),fr->ePBC,fr->box,d->bSave);
    d->fnConnelly = NULL;
  }
  if (d->bFindex) {
    for (i = 0; i < d->fsel->g->isize; ++i)
      d->bPhobic[d->fsel->g->index[i]] = TRUE;
  }

  /* Update atom and residue areas */
  if (d->bResAt) {
    for (i = 0; i < top->atoms.nres; ++i)
      d->res_a[i] = 0;
    for (i = 0; i < d->nwsel->p.nr; ++i) {
      ii = d->nwsel->g->index[i];
      at_area = area[i];
      if (d->bResAt) {
        d->atom_area[d->nwsel->p.m.refid[i]]  += at_area;
        d->atom_area2[d->nwsel->p.m.refid[i]] += sqr(at_area);
        d->res_a[top->atoms.atom[ii].resind] += at_area;
      }
    }
    for (i = 0; i < top->atoms.nres; ++i) {
      d->res_area[i] += d->res_a[i];
      d->res_area2[i] += sqr(d->res_a[i]);
    }
  }

  /* Loop through the output groups */
  for (g = 0; g < nr; ++g) {
    harea  = 0;
    tarea  = 0;
    dgsolv = 0;
    k      = 0;
    for (i = 0; i < d->nwsel->p.nr; ++i) {
      ii = d->nwsel->g->index[i];
      bPhobic = d->bPhobic[ii];
      /* Here we assume that the calculation group contains all the output
       * groups and that the groups are sorted. */
      if (sel[g]->g->index[k] == ii) {
        at_area = area[i];
        tarea += at_area;
        if (d->bDGsol)
          dgsolv += at_area*d->dgs_factor[d->nwsel->p.m.refid[i]];
        if (bPhobic)
          harea += at_area;
        ++k;
      }
    }
    fprintf(d->fp[g],"%10g  %10g  %10g  %10g",fr->time,harea,tarea-harea,tarea);
    if (d->bDGsol)
      fprintf(d->fp[g],"  %10g\n",dgsolv);
    else
      fprintf(d->fp[g],"\n");
  }

  /* Print volume */
  if (d->vp) {
    density = d->totmass*AMU/(totvolume*NANO*NANO*NANO);
    fprintf(d->vp,"%12.5e  %12.5e  %12.5e\n",fr->time,totvolume,density);
  }
  if (area) {
    sfree(area);
    area = NULL;
  }
  if (surfacedots) {
    sfree(surfacedots);
    surfacedots = NULL;
  }
  return 0;
}

void sas_plot(gmx_ana_traj_t *trj,int nfile,t_filenm fnm[],
              real solsize,int ndots,real qcut,bool bSave,real minarea,
	      real dgs_default,bool bFindex)
{
  FILE         *fp,*fp2,*fp3=NULL;
  char         *flegend[] = { "Hydrophobic", "Hydrophilic",
			      "Total", "D Gsolv" };
  char         *vlegend[] = { "Volume (nm\\S3\\N)", "Density (g/l)" };
  char        **fnsOut;
  char         *vfile;
  gmx_atomprop_t aps=NULL;
  t_topology   *top;
  t_atoms      *atoms;
  int          ngrps;
  gmx_ana_selection_t **sel;
  t_trxframe   *fr;
  int          nframes;
  int          noutf;
  int          ndefault;
  int          i,j,ii,res;
  bool         bITP;
  real         fluc2;
  int          nphobic;
  t_sasdata    d;

  gmx_ana_get_topology(trj, TRUE, &top, NULL);
  noutf        = opt2fns(&fnsOut, "-o",nfile,fnm);
  atoms        = &top->atoms;
  bITP         = opt2bSet("-i",nfile,fnm);
  d.ndots      = ndots;
  d.bSave      = bSave;
  d.bResAt     = opt2bSet("-or",nfile,fnm) || opt2bSet("-oa",nfile,fnm) || bITP;
  d.bDGsol     = strcmp(*(atoms->atomtype[0]),"?") != 0;
  d.bFindex    = bFindex;
  d.fnConnelly = opt2fn_null("-q",nfile,fnm);
  gmx_ana_get_refsel(trj, 0, &d.nwsel);
  if (bFindex)
    gmx_ana_get_refsel(trj, 0, &d.fsel);
  else
    d.fsel = NULL;
  gmx_ana_get_nanagrps(trj, &ngrps);
  gmx_ana_get_anagrps(trj, &sel);

  if (noutf != ngrps)
    gmx_fatal(FARGS, "The number of output files (%d) and the number of "
              "output groups (%d) should be equal", noutf, ngrps);
  if (!d.bDGsol) {
    fprintf(stderr,"Warning: your tpr file is too old, will not compute "
	    "Delta G of solvation\n");
  } else {
    printf("In case you use free energy of solvation predictions:\n");
    please_cite(stdout,"Eisenberg86a");
  }

  if (!gmx_ana_index_check_sorted(d.nwsel->g))
    gmx_fatal(FARGS, "Calculation group not sorted or contains duplicates");
  if (bFindex) {
    if (!gmx_ana_index_check_sorted(d.fsel->g))
      gmx_fatal(FARGS, "Hydrophobic group not sorted or contains duplicates");
    if (!gmx_ana_index_contains(d.nwsel->g, d.fsel->g))
      fprintf(stderr,"NOTE: hydrophobic index group not contained in the calculation group\n");
  }
  for (i = 0; i < ngrps; ++i) {
    if (!gmx_ana_index_check_sorted(sel[i]->g))
      gmx_fatal(FARGS, "Output group '%s' not sorted or contains duplicates",
                sel[i]->name);
    if (!gmx_ana_index_contains(d.nwsel->g, sel[i]->g))
      gmx_fatal(FARGS, "Output group '%s' not a subset of the calculation group",
                sel[i]->name);
  }

  aps = gmx_atomprop_init();
  
  gmx_ana_get_first_frame(trj, &fr);
  fprintf(stderr, "\n");

  if ((fr->ePBC != epbcXYZ) && gmx_ana_has_pbc(trj)) {
    fprintf(stderr,"\n\nWARNING: Analysis based on vacuum simulations (with the possibility of evaporation)\n" 
	    "will certainly crash the analysis. Turning off pbc.\n\n");
    gmx_ana_set_pbc(trj, FALSE);
  }

  /* Now compute atomic radii including solvent probe size */
  snew(d.radius,  fr->natoms);
  snew(d.bPhobic, fr->natoms);
  if (d.bResAt) {
    snew(d.atom_area,  d.nwsel->p.nr);
    snew(d.atom_area2, d.nwsel->p.nr);
    snew(d.res_a,      atoms->nres);
    snew(d.res_area,   atoms->nres);
    snew(d.res_area2,  atoms->nres);
  }
  if (d.bDGsol)
    snew(d.dgs_factor, d.nwsel->p.nr);

  /* Get a Van der Waals radius for each atom */
  ndefault = 0;
  for (i = 0; i < fr->natoms; ++i) {
    if (!gmx_atomprop_query(aps,epropVDW,
			    *(top->atoms.resinfo[top->atoms.atom[i].resind].name),
			    *(top->atoms.atomname[i]),&d.radius[i]))
      ndefault++;
    /* radius[i] = calc_radius(*(top->atoms.atomname[i])); */
    d.radius[i] += solsize;
  }
  if (ndefault > 0)
    fprintf(stderr,"WARNING: could not find a Van der Waals radius for %d atoms\n",ndefault);

  /* Determine which atom is counted as hydrophobic */
  nphobic = 0;
  if (bFindex) {
    for (i = 0; i < d.fsel->g->isize; ++i) {
      ii = d.fsel->g->index[i];
      d.bPhobic[ii] = TRUE;
    }
    /* The bPhobic array only needs to be updated in analyze_frame() if
     * the hydrophobic group is dynamic. */
    if (!d.fsel->bDynamic)
      d.bFindex = FALSE;
  }

  for (i = 0; i < d.nwsel->g->isize; ++i) {
    ii = d.nwsel->g->index[i];
    if (!bFindex) {
      d.bPhobic[ii] = fabs(atoms->atom[ii].q) <= qcut;
      if (d.bPhobic[ii])
        nphobic++;
    }
    if (d.bDGsol)
      if (!gmx_atomprop_query(aps,epropDGsol,
                              *(atoms->resinfo[atoms->atom[ii].resind].name),
                              *(atoms->atomtype[ii]),&d.dgs_factor[i]))
        d.dgs_factor[i] = dgs_default;
    if (debug)
      fprintf(debug,"Atom %5d %5s-%5s: q= %6.3f, r= %6.3f, dgsol= %6.3f, hydrophobic= %s\n",
              ii+1,*(atoms->resinfo[atoms->atom[ii].resind].name),
              *(atoms->atomname[ii]),
              atoms->atom[ii].q,d.radius[ii]-solsize,d.dgs_factor[i],
              BOOL(d.bPhobic[ii]));
  }
  if (!bFindex)
    fprintf(stderr,"%d out of %d atoms were classified as hydrophobic\n",
            nphobic,d.nwsel->g->isize);
  
  snew(d.fp, ngrps);
  for (i = 0; i < ngrps; ++i) {
    d.fp[i]=xvgropen(fnsOut[i],"Solvent Accessible Surface","Time (ps)",
                "Area (nm\\S2\\N)");
    xvgr_legend(d.fp[i],asize(flegend) - (d.bDGsol ? 0 : 1),flegend);
  }
  vfile = opt2fn_null("-tv",nfile,fnm);
  if (vfile) {
    d.vp=xvgropen(vfile,"Volume and Density","Time (ps)","");
    xvgr_legend(d.vp,asize(vlegend),vlegend);
    d.totmass  = 0;
    ndefault = 0;
    for (i = 0; i < d.nwsel->p.nr; i++) {
      real mm;
      ii = d.nwsel->g->index[i];
      /*
      if (!query_atomprop(atomprop,epropMass,
			  *(top->atoms.resname[top->atoms.atom[ii].resnr]),
			  *(top->atoms.atomname[ii]),&mm))
	ndefault++;
      totmass += mm;
      */
      d.totmass += atoms->atom[ii].m;
    }
    if (ndefault)
      fprintf(stderr,"WARNING: Using %d default masses for density calculation, which most likely are inaccurate\n",ndefault);
  }
  else
    d.vp = NULL;
    
  gmx_atomprop_destroy(aps);

  gmx_ana_do(trj, 0, &analyze_frame, &d);
  gmx_ana_get_nframes(trj, &nframes);
    
  fprintf(stderr,"\n");
  for (i = 0; i < ngrps; ++i)
    fclose(d.fp[i]);
  if (d.vp)
    fclose(d.vp);
    
  /* if necessary, print areas per atom to file too: */
  if (d.bResAt) {
    for(i=0; i<atoms->nres; i++) {
      d.res_area[i]  /= nframes;
      d.res_area2[i] /= nframes;
    }
    for (i = 0; i < d.nwsel->p.nr; ++i) {
      d.atom_area[i]  /= nframes;
      d.atom_area2[i] /= nframes;
    }
    fprintf(stderr,"Printing out areas per atom\n");
    fp  = xvgropen(opt2fn("-or",nfile,fnm),"Area per residue","Residue",
		   "Area (nm\\S2\\N)");
    fp2 = xvgropen(opt2fn("-oa",nfile,fnm),"Area per atom","Atom #",
		   "Area (nm\\S2\\N)");
    if (bITP) {
      fp3 = ftp2FILE(efITP,nfile,fnm,"w");
      fprintf(fp3,"[ position_restraints ]\n"
	      "#define FCX 1000\n"
	      "#define FCY 1000\n"
	      "#define FCZ 1000\n"
	      "; Atom  Type  fx   fy   fz\n");
    }
    for (i = 0; i < d.nwsel->p.nr; ++i) {
      ii = d.nwsel->g->index[i];
      res = atoms->atom[ii].resind;
      if (i == d.nwsel->p.nr-1 ||
          res != atoms->atom[d.nwsel->g->index[i+1]].resind) {
	fluc2 = d.res_area2[res] - sqr(d.res_area[res]);
	if (fluc2 < 0)
	  fluc2 = 0;
	fprintf(fp,"%10d  %10g %10g\n",
                atoms->resinfo[res].nr,d.res_area[res],sqrt(fluc2));
      }
      fluc2 = d.atom_area2[i]-sqr(d.atom_area[i]);
      if (fluc2 < 0)
	fluc2 = 0;
      fprintf(fp2,"%d %g %g\n",ii+1,d.atom_area[i],sqrt(fluc2));
      if (bITP && (d.atom_area[i] > minarea))
	fprintf(fp3,"%5d   1     FCX  FCY  FCZ\n",ii+1);
    }
    if (bITP)
      fclose(fp3);
    fclose(fp2);
    fclose(fp);
  }
}

int gmx_sas(int argc,char *argv[])
{
  const char *desc[] = {
    "g_sas computes hydrophobic, hydrophilic and total solvent accessible surface area.",
    "As a side effect the Connolly surface can be generated as well in",
    "a pdb file where the nodes are represented as atoms and the vertices",
    "connecting the nearest nodes as CONECT records.",
    "The program will ask for a group for the surface calculation",
    "and a group for the output. The calculation group should always",
    "consists of all the non-solvent atoms in the system.",
    "The output group can be the whole or part of the calculation group.",
    "The area can be plotted",
    "per residue and atom as well (options [TT]-or[tt] and [TT]-oa[tt]).",
    "In combination with the latter option an [TT]itp[tt] file can be",
    "generated (option [TT]-i[tt])",
    "which can be used to restrain surface atoms.[PAR]",
    "By default, periodic boundary conditions are taken into account,",
    "this can be turned off using the [TT]-nopbc[tt] option.[PAR]",
    "With the [TT]-tv[tt] option the total volume and density of the molecule can be",
    "computed.",
    "Please consider whether the normal probe radius is appropriate",
    "in this case or whether you would rather use e.g. 0. It is good",
    "to keep in mind that the results for volume and density are very",
    "approximate, in e.g. ice Ih one can easily fit water molecules in the",
    "pores which would yield too low volume, too high surface area and too",
    "high density."
  };

  static real solsize = 0.14;
  static int  ndots   = 24;
  static real qcut    = 0.2;
  static real minarea = 0.5, dgs_default=0;
  static bool bSave   = TRUE, bFindex=FALSE;
  t_pargs pa[] = {
    { "-probe", FALSE, etREAL, {&solsize},
      "Radius of the solvent probe (nm)" },
    { "-ndots",   FALSE, etINT,  {&ndots},
      "Number of dots per sphere, more dots means more accuracy" },
    { "-qmax",    FALSE, etREAL, {&qcut},
      "The maximum charge (e, absolute value) of a hydrophobic atom" },
    { "-f_index", FALSE, etBOOL, {&bFindex},
      "Determine from a group in the index file what are the hydrophobic atoms rather than from the charge" },
    { "-minarea", FALSE, etREAL, {&minarea},
      "The minimum area (nm^2) to count an atom as a surface atom when writing a position restraint file  (see help)" },
    { "-prot",    FALSE, etBOOL, {&bSave},
      "Output the protein to the connelly pdb file too" },
    { "-dgs",     FALSE, etREAL, {&dgs_default},
      "default value for solvation free energy per area (kJ/mol/nm^2)" }
  };
  t_filenm  fnm[] = {
    { efXVG, "-o",   "area",     ffWRMULT },
    { efXVG, "-or",  "resarea",  ffOPTWR },
    { efXVG, "-oa",  "atomarea", ffOPTWR },
    { efXVG, "-tv",  "volume",   ffOPTWR },
    { efPDB, "-q",   "connelly", ffOPTWR },
    { efITP, "-i",   "surfat",   ffOPTWR }
  };
#define NFILE asize(fnm)

  gmx_ana_traj_t *trj;

  CopyRight(stderr,argv[0]);
  gmx_ana_traj_create(&trj, ANA_REQUIRE_TOP | ANA_USER_SELINIT | ANA_ONLY_ATOMPOS);
  gmx_ana_set_nrefgrps(trj, 1);
  gmx_ana_set_nanagrps(trj, -1);
  parse_trjana_args(trj, &argc,argv,PCA_CAN_VIEW,
		    NFILE,fnm,asize(pa),pa,asize(desc),desc,0,NULL);
  if (bFindex)
    gmx_ana_set_nrefgrps(trj, 2);
  gmx_ana_init_selections(trj);
  if (solsize < 0) {
    solsize=1e-3;
    fprintf(stderr,"Probe size too small, setting it to %g\n",solsize);
  }
  if (ndots < 20) {
    ndots = 20;
    fprintf(stderr,"Ndots too small, setting it to %d\n",ndots);
  }

  please_cite(stderr,"Eisenhaber95");
    
  sas_plot(trj,NFILE,fnm,solsize,ndots,qcut,bSave,minarea,dgs_default,bFindex);
  
  do_view(opt2fn("-o",NFILE,fnm),"-nxy");
  do_view(opt2fn_null("-or",NFILE,fnm),"-nxy");
  do_view(opt2fn_null("-oa",NFILE,fnm),"-nxy");

  thanx(stderr);
  
  return 0;
}
