==========
Change Log
==========

# Changes

## 0.0.2

* Bind plugin, set parameters from Python, run on master rank.
* Explore parallelization strategies. *ForceProviders operate on localized arrays, while we would specifically need
  to refer to global state. However, we could add a hack to grab a reference to the
  global state array earlier on as a temporary measure for tMPI and use the DD
  atom indexing helper.*

# Roadmap

## unversioned:

* additional C++ API exceptions
* base Python exceptions on C++ exceptions
* base Python Status object on C++ Status object
* user message handler

## 0.0.2

* Bind plugin, set parameters from Python, run on master rank.
* check whether easy parallelization with thread-MPI works right: *it does not.
  ForceProviders operate on localized arrays, while we would specifically need
  to refer to global state. However, we could add a hack to grab a reference to the
  global state array earlier on as a temporary measure for tMPI and use the DD
  atom indexing helper.*

## 0.0.3 (estimated time: 40 hours)

* Simplify runner state machine (minimal UI change, substantial API change)
* expand flexibility of when plugin can be bound and interacted with
* Must be compatible with DD. If thread-MPI didn't work for non-local
  particles, borrow or mimic pull code COM facilities
  and use the same paradigm for local application of forces.
* Fix documentation self-consistency.
* NO NEW FEATURES: Get this done and shared with Jennifer by Dec. 1.

## 0.0.4 (estimated time: 30 hours)

* Update API compatibility checks.
* abstract work spec and serialize
* templated simplification and setup of plugin parameters
* improve flexibility of restrained pair specification?

## 0.0.5 (estimated time: 40)

* improve parallelism with startup from work spec
* express gmx::MdRunner creation in terms of work spec with specifications for
  input sources.
* express plugin parameters and data in terms of work-spec data sources
* share design documents

## 0.0.6: reconciliation part 1 (est: 20 hours)

* apply updates from GROMACS master
* tag v0.0.6

## 0.0.7: reconciliation part 2 (est: 20 hours)

* bump version to 0.0.7 (development)
* branch fresh feature-submission branches from master that would collectively
  bring GROMACS master tip to gmxapi master tip
* try again to submit infrastructure changes from feature branches (Gerrit and Redmine)
* as necessary, branch feature-update branches from 0.0.7 to reflect differences
  in features as submitted or updated on Gerrit.
* merge and close feature-update branches

## 0.0.8: attempt to resume normal workflow

* bump version to 0.0.8
* port active feature-submission branches (rebase to last-merged master) to make
  it easier to patch feature-update branches
* Note in Changelog and branch a new feature-update for each outstanding submitted feature for
  integration testing of patch sets and such. cherry-pick feature-submission commits
* make new gmxapi feature branches
* make new feature-submission branches from feature branches as warranted
* merge feature branches and note in Changelog
* merge GROMACS master and note in Changelog
* merge feature-update branches and note in Changelog whether still outstanding

## 0.1.0: first attempt at stability

* adequate client / library version compatibility checking

Someday, we can get to a point where enough infrastructure is in GROMACS master
that gmxapi feature development can branch directly from master. At some point,
I should articulate the roadmap for how to reach that point. Probably during 0.0.8.

The requirement would basically be that any feature under development is a child
of master or of at most one feature, such that when the parent feature is merged
to master, the difference between the accepted change and the child's branch point
can be merged from the latest version of the feature branch, because submissions
need to be generated by first merging the latest master, creating a submission
branch, then doing 'git reset' to master to prepare the first patch set commit.

The first commit on the submission branch should exactly match the final commit
on the feature branch. If changes are required before submission, they should be
captured as commits to the submission branch that can be rebased onto the
feature branch, and then the feature can `merge --ff-only` to the new tip commit.
Each Gerrit patch set is then prepared by `git reset`ing a new branch from the
feature tip to the parent commit. `merge --squash` is not used because it can
accidentally preserve extra histories from squashed merge commits.
A child feature should merge only its parent branch
before preparing a submission, and only its parent branch.

## Git strategy

Feature branches are only merged to gmxapi/master if part of the current version
and only after being extracted to a feature-submission branch, which is branched
from GROMACS master and used to prepare a Gerrit change.

Unmerged features can tag their tip as "done" for an old version and be ported
to the next. Retaining a reference to the old tip could help in preparing
patches for feature revisions that happen through Gerrit patch sets or
out-of-synch development based on the old feature.

At the end of an iteration, either merge feature branches or port them (rebase)
to the next iteration. Note in the Changelog. At the beginning of an iteration,
ideally, an integration branch of gmxapi/master tip with ported features matches
an integration branch of gromacs/master with the outstanding Gerrit changes and
rebased unsubmitted features applied in clean merges. Else, compartmentalize
differences in additional features, such as to track patch sets for previously
posted but unincorporated Gerrit changes. Note in the Changelog. Whether or not
the Gerrit change is accepted before the next iteration, these extra
feature-update branches will be merged or ported.

## Needed GROMACS infrastructure

* Clarify phases of simulation startup
    * client duties (user interface / arg parsing, specify work, prepare input
      needed to set up execution context, trigger context startup->run->teardown)
    * compute context (set up appropriate parallel resources, messaging, and logging)
    * get inputs where they need to be
    * construct and configure objects to perform work
    * execute protocol for performing work with appropriate hooks or call-backs
* Environment dependent on how invoked (part of execution context)
    * user messages
    * parameters (parsed option arguments) source
    * atom configuration source
    * topology source
    * integrator state source
* Hooks at which data of a known state can be copied in or out.
* Notifier for updated data to dependents
* Managed data access to avoid unnecessary copies
* Managed distributed data to allow exploiting data locality and avoid
  unnecessary communication
* C/C++ API to provide work specification
* Base class for context manager that knows how to get factory functions for the
  specified work. Context manager for Python-driven work can call out to Python to get
  plugin handles.
* selection objects that can replace pull groups (provide center-of-mass
  functionality, handle data locality, handle communication for locally-required
  data)

* a way to find a Python interpreter with `mpi4py` compiled against the same
  MPI implementation (otherwise we have to pass up a communicator with necessary
  bindings through gmxapi).

