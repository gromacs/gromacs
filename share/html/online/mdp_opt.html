'<HTML>
<HEAD>
<TITLE>mdp options</TITLE>
<LINK rel=stylesheet href="style.css" type="text/css">
<BODY text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#990000" alink="#FF0000">
<TABLE WIDTH="98%" NOBORDER >
<TR><TD WIDTH=400>
<TABLE WIDTH=400 NOBORDER>
<TD WIDTH=116>
<a href="http://www.gromacs.org/"><img SRC="../images/gmxlogo_small.png"BORDER=0></a></td>
<td ALIGN=LEFT VALIGN=TOP WIDTH=280><br><h2>mdp options</h2><font size=-1><A HREF="../online.html">Main Table of Contents</A></font><br><br></td>
</TABLE></TD><TD WIDTH="*" ALIGN=RIGHT VALIGN=BOTTOM><p> </p><B>VERSION 3.3<br>
Thu 11 May 2006</B></td></tr></TABLE>
<HR>

<!-- 

PLEASE BE VERY CAREFUL WHEN EDITING THIS FILE: IT MUST BE
AUTOMATICALLY PARSED BY A SIMPLE SCRIPT (doc/mkmdp) TO PRODUCE A
CORRESPONDING LATEX FILE.

IF YOU'RE NOT SURE ABOUT WHAT YOU'RE DOING, DON'T DO IT!

-->

<H3>Table of Contents</H3>

<ul>
<li><A HREF="#general"><b>General remarks</b></A>
<p> </p>
<li><A HREF="#pp"><b>preprocessing</b></A> (title, warnings, cpp, include, define)
<li><A HREF="#run"><b>run control</b></A> (integrator, tinit, dt, nsteps, init_step, comm_mode, nstcomm, comm_grps)
<li><A HREF="#ld"><b>langevin dynamics</b></A> (bd_fric, ld_seed)
<li><A HREF="#em"><b>energy minimization</b></A> (emtol, emstep, nstcgsteep)
<li><a HREF="#xmdrun"><b>shell molecular dynamics</b></a>(emtol,niter,fcstep)
<li><A HREF="#out"><b>output control</b></A> (nstxout, nstvout, nstfout, nstlog, nstenergy, nstxtcout, xtc_precision, xtc_grps, energygrps)
<li><A HREF="#nl"><b>neighbor searching</b></A> (nstlist, ns_type, pbc, rlist)
<li><A HREF="#el"><b>electrostatics</b></A> (coulombtype, rcoulomb_switch, rcoulomb, epsilon_r, epsilon_rf)
<li><A HREF="#vdw"><b>VdW</b></A> (vdwtype, rvdw_switch, rvdw, DispCorr)
<li><A HREF="#table"><b>tables</b></A> (table-extension, energygrp_table)
<li><A HREF="#ewald"><b>Ewald</b></A> (fourierspacing, fourier_nx, fourier_ny, fourier_nz, pme_order, ewald_rtol, ewald_geometry, epsilon_surface, optimize_fft)
<li><A HREF="#tc"><b>Temperature coupling</b></A> (tcoupl, tc_grps, tau_t, ref_t)
<li><A HREF="#pc"><b>Pressure coupling</b></A> (pcoupl, pcoupltype, tau_p, compressibility, ref_p)
<li><A HREF="#sa"><b>simulated annealing</b></A> (annealing, annealing_npoints, annealing_time, annealing_temp)
<li><A HREF="#vel"><b>velocity generation</b></A> (gen_vel, gen_temp, gen_seed)
<li><A HREF="#bond"><b>bonds</b></A> (constraints, constraint_algorithm, unconstrained_start, shake_tol, lincs_order, lincs_iter, lincs_warnangle, morse)
<li><A HREF="#egexcl"><b>Energy group exclusions</b></A> (energygrp_excl)
<li><A HREF="#nmr"><b>NMR refinement</b></A> (disre, disre_weighting, disre_mixed, disre_fc, disre_tau, nstdisreout, orire, orire_fc, orire_tau, orire_fitgrp, nstorireout)
<li><A HREF="#free"><b>Free Energy Perturbation</b></A> (free_energy, init_lambda, delta_lambda, sc_alpha, sc_power, sc_sigma)
<li><A HREF="#neq"><b>Non-equilibrium MD</b></A> (acc_grps, accelerate, freezegrps, freezedim, cos_acceleration, deform)
<li><A HREF="#ef"><b>Electric fields</b></A> (E_x, E_xt, E_y, E_yt, E_z, E_zt )
<li><A HREF="#qmmm"><b>Mixed quantum/classical dynamics</b></A> (QMMM, QMMM-grps, QMMMscheme, QMmethod, QMbasis, QMcharge, Qmmult, CASorbitals, CASelectrons, SH)
<li><A HREF="#user"><b>User defined thingies</b></A> (user1_grps, user2_grps, userint1, userint2, userint3, userint4, userreal1, userreal2, userreal3, userreal4)
<li><A HREF="#idx"><b>Index</b></A>
</ul>
</P>

<HR>

<A NAME="general"><br>
<h3>General</h3>

<P>
Default values are given in parentheses. The first option is
always the default option. Units are given in square brackets The
difference between a dash and an underscore is ignored. </P>

<P>
A <a href="mdp.html">sample <TT>.mdp</TT> file</a> is
available. This should be appropriate to start a normal
simulation. Edit it to suit your specific needs and desires. </P>

<A NAME="pp"><br>
<hr>
<h3>Preprocessing</h3>

<dl>
<dt><h4>title:</h4></dt>
<dd>this is redundant, so you can type anything you want</dd>
<dt><h4>cpp: (cpp)</h4></dt>
<dd>your preprocessor</dd>
<dt><h4>include:</h4></dt>
<dd>directories to include in your topology. Format: 
<PRE>-I/home/john/my_lib -I../more_lib</PRE></dd>
<dt><h4>define: ()</h4></dt>
<dd>defines to pass to the preprocessor, default is no defines. You can use
any defines to control options in your customized topology files. Options
that are already available by default are:
<dd><dl compact>
<dt><b>-DFLEXIBLE</b>
<dd>Will tell grompp to include flexible water in stead of rigid water into your
topology, this is necessary to make 
<b><A HREF="#run">conjugate gradients</A></b> or
<b><A HREF="#run">l-bfgs</A></b> minimization work and will allow 
<b><A HREF="#run">steepest descent</A></b> to minimize further.</dd>
<dt><b>-DPOSRES</b></dt>
<dd>Will tell grompp to include posre.itp into your topology, used for
<!--Idx-->position restraints<!--EIdx-->.</dd>
</dl>
</dl>

<A NAME="run"><br>
<hr>
<h3>Run control</h3>

<dl>
<dt><h4>integrator:</h4></dt>
<dd><dl compact></dd>
<dt><b>md</b></dt>
<dd>A <!--Idx-->leap-frog<!--EIdx--> algorithm for integrating Newton's
equations of motion.</dd>
<dt><b>sd</b></dt>
<dd> A leap-frog stochastic dynamics integrator. The temperature for
one or more groups of atoms (<b><A HREF="#tc">tc_grps</A></b>)
is set with <b><A HREF="#tc">ref_t</A></b> [K],
the inverse friction constant for each group is set with
<b><A HREF="#tc">tau_t</A></b> [ps]. The parameter <b><A HREF="#tc">tcoupl</A></b>
is ignored.
The random generator is initialized with <b><A HREF="#ld">ld_seed</A></b>.
<b>NOTE:</b> temperature deviations decay twice as fast as with
a Berendsen thermostat with the same <b>tau_t</b>.</dd>
<dt><b>bd</b></dt>
<dd>An Euler integrator for Brownian or position Langevin dynamics, the
velocity is the force divided by a friction coefficient 
(<b><A HREF="#ld">bd_fric</A></b> [amu ps<sup>-1</sup>])
plus random thermal noise (<b><A HREF="#tc">ref_t</A></b>).
When <b><A HREF="#ld">bd_fric</A></b>=0, the friction coefficient for each
particle is calculated as mass/<b><A HREF="#tc">tau_t</A></b>, as for the
integrator <tt>sd</tt>.
The random generator is initialized with <b><A HREF="#ld">ld_seed</A></b>.</dd>

<dt>The following algorithms are not integrators, but selected using 
the integrator tag anyway</dt>
<dt><b>steep</b></dt>
<dd>A <!--Idx-->steepest descent<!--EIdx--> algorithm for energy
minimization. The maximum step size is <b><A HREF="#em">emstep</A></b>
[nm], the tolerance is <b><A HREF="#em">emtol</A></b> [kJ
mol<sup>-1</sup> nm<sup>-1</sup>].</dd>
<dt><b>cg</b></dt>
<dd>A <!--Idx-->conjugate gradient<!--EIdx--> algorithm for energy
minimization, the tolerance is <b>emtol</b> [kJ mol<sup>-1</sup>
nm<sup>-1</sup>]. CG is more efficient when a steepest descent step
is done every once in a while, this is determined by 
<b><A HREF="#em">nstcgsteep</A></b>.
For a minimization prior to a normal mode analysis, which requires
a very high accuracy, GROMACS should be compiled in double precision.</dd>
<dt><b>l-bfgs</b></dt>
<dd>A <!--Idx-->quasi-Newtonian<!--EIdx--> algorithm for energy minimization
according to the low-memory Broyden-Fletcher-Goldfarb-Shanno approach.
In practice this seems to converge faster than Conjugate Gradients, but due
to the correction steps necessary it is not (yet) parallelized.
</dd>
<dt><b>nm</b></dt>
<dd><!--Idx-->Normal mode analysis<!--EIdx--> is performed
on the structure in the <tt>tpr</tt> file. GROMACS should be
compiled in double precision.</dd>
<dt><b>tpi</b></dt>
<dd> Test particle insertion. The last atom in the topology
is the test particle. A trajectory should be provided with
the <tt>-rerun</tt> option of <tt>mdrun</tt>. This trajectory
should contain one atom less than the topology. Insertions
are performed <b>nsteps</b> times in each frame. When <b>nstlist</b>
is larger than one, after a first 'normal' insertion <b>nstlist</b>-1
insertions are performed in a sphere with radius 0.05*<b>rlist</b>
around the 'first' location using the same neighborlist
(and the same long-range energy when <b>rvdw</b> or <b>rcoulomb</b>
&gt <b>rlist</b>).
Since neighborlist construction is expensive one can perform several
extra insertions with the same list almost for free.
The random seed is set with <b><A HREF="#ld">ld_seed</A></b>.
The temperature for the Boltzmann weighting is set with
<b><A HREF="#tc">ref_t</A></b>, this should match the temperature
of the simulation of the original trajectory.
Dispersion correction is implemented correctly for tpi.
All relevant quantities are written using the <tt>-tpi</tt> option
of <tt>mdrun</tt>. No trajectory or energy file is written.
</dd>
</dl>

<dt><h4>tinit: (0) [ps]</h4></dt>
<dd>starting time for your run (only makes sense for integrators <tt>md</tt>,
<tt>sd</tt> and <tt>bd</tt>)</dd>
<dt><h4>dt: (0.001) [ps]</h4></dd>
<dd>time step for integration (only makes sense for integrators <tt>md</tt>,
<tt>sd</tt> and <tt>bd</tt>)</dd>
<dt><h4>nsteps: (0)</h4></dt>
<dd>maximum number of steps to integrate</dd>
<dt><h4>init_step: (0)</h4></dt>
<dd>The starting step.
The time at an step i in a run is calculated as: t = <tt>tinit</tt> + <tt>dt</tt>*(<tt>init_step</tt> + i).
The free-energy lambda is calculated as: lambda = <tt>init_lambda</tt> + <tt>delta_lambda</tt>*(<tt>init_step</tt> + i).
Also non-equilibrium MD parameters can depend on the step number.
Thus for exact restarts or redoing part of a run it might be necessary to
set <tt>init_step</tt> to the step number of the restart frame.
<tt>tpbconv</tt> does this automatically.
</dd>
<dt><h4>comm_mode:</h4></dt>
<dd><dl compact>
<dt><b>Linear</b></dt>
<dd>Remove center of mass translation</dd>
<dt><b>Angular</b></dt>
<dd>Remove center of mass translation and rotation around the center of mass
</dd>
<dt><b>No</b></dt>
<dd>No restriction on the center of mass motion
</dl></dd>
<dt><h4>nstcomm: (1) [steps]</h4></dt>
<dd>frequency for center of mass motion removal</dd>
<dt><h4>comm_grps:</h4></dt>
<dd>group(s) for center of mass motion removal, default is the whole system</dd>
</dl>

<A NAME="ld"><br>
<hr>
<h3><!--Idx-->Langevin dynamics<!--EIdx--></h3>

<dl>
<dt><h4>bd_fric: (0) [amu ps<sup>-1</sup>]</h4></dt>
<dd>Brownian dynamics friction coefficient.
When <b>bd_fric</b>=0, the friction coefficient for each
particle is calculated as mass/<b><A HREF="#tc">tau_t</A></b>.</dd>
<dt><h4>ld_seed: (1993) [integer]</h4></dt>
<dd>used to initialize random generator for thermal noise
for stochastic and Brownian dynamics.
When <b>ld_seed</b> is set to -1, the seed is calculated as
<tt>(time() + getpid()) % 1000000</tt></dd>.
When running on multiple processors, each processor uses a seed equal
to <b>ld_seed</b> plus the processor number.
</dl>

<A NAME="em"><br>
<hr>
<h3><!--Idx-->Energy minimization<!--EIdx--></h3>
<dl>
<dt><h4>emtol: (10.0) [kJ mol<sup>-1</sup> nm<sup>-1</sup>]</h4></dt>
<dd>the minimization is converged when the maximum force is smaller than 
this value</dd>
<dt><h4>emstep: (0.01) [nm]</h4></dt>
<dd>initial step-size</dd>
<dt><h4>nstcgsteep: (1000) [steps]</h4></dt>
<dd>frequency of performing 1 steepest descent step while doing
conjugate gradient energy minimization.</dd>
<dt><h4>nbfgscorr: (10)</h4></dt>
<dd>Number of correction steps to use for L-BFGS minimization. A higher
number is (at least theoretically) more accurate, but slower.</dd>

</dl>

<A NAME="xmdrun"><br>
<hr>
<h3><!--Idx-->Shell Molecular Dynamics<!--EIdx--></h3> When shells or
flexible constraints are present in the system the positions of the shells
and the lengths of the flexible constraints are optimized at
every time step until either the RMS force on the shells and constraints
is less than emtol, or a maximum number of iterations (niter) has been reached
<dl>
<dt><h4>emtol: (10.0) [kJ mol<sup>-1</sup> nm<sup>-1</sup>]</h4></dt>
<dd>the minimization is converged when the maximum force is smaller than 
this value. For shell MD this value should be 1.0 at most, but since the
variable is used for energy minimization as well the default is 10.0.</dd>
<dt><h4>niter: (20)</h4></dt>
<dd>maximum number of iterations for optimizing the shell positions
and the flexible constraints.</dd>
<dt><h4>fcstep: (0) [ps<sup>2</sup>]</h4></dt>
<dd>the step size for optimizing the flexible constraints.
Should be chosen as mu/(d<sup>2</sup>V/d q<sup>2</sup>)
where mu is the reduced mass of two particles in a flexible constraint
and d<sup>2</sup>V/d q<sup>2</sup> is the second derivative of the potential
in the constraint direction. Hopefully this number does not differ too
much between the flexible constraints, as the number of iterations
and thus the runtime is very sensitive to <tt>fcstep</tt>.
Try several values!</dd>
</dl>


<A NAME="out"><br>
<hr>
<h3>Output control</h3>
<dl>
<dt><h4>nstxout: (100) [steps]</h4></dt>
<dd>frequency to write coordinates to output 
<!--Idx-->trajectory file<!--EIdx-->, the last coordinates are always written</dd>
<dt><h4>nstvout: (100) [steps]</h4></dt>
<dd>frequency  to write velocities to output trajectory,
the last velocities are always written</dd>
<dt><h4>nstfout: (0) [steps]</h4></dt>
<dd>frequency to write forces to output trajectory.</dd>
<dt><h4>nstlog: (100) [steps]</h4></dt>
<dd>frequency to write energies to <!--Idx-->log file<!--EIdx-->,
the last energies are always written</dd>
<dt><h4>nstenergy: (100) [steps]</h4></dt>
<dd>frequency to write energies to energy file,
the last energies are always written</dd>
<dt><h4>nstxtcout: (0) [steps]</h4></dt>
<dd>frequency to write coordinates to xtc trajectory</dd>
<dt><h4>xtc_precision: (1000) [real]</h4></dt>
<dd>precision to write to xtc trajectory</dd>
<dt><h4>xtc_grps:</h4></dt>
<dd>group(s) to write to xtc trajectory, default the whole system is written
(if <b>nstxtcout</b> is larger than zero)</dd>
<dt><h4>energygrps:</h4></dt>
<dd>group(s) to write to energy file</dd>
</dl>

<A NAME="nl"><br>
<hr>
<h3><!--Idx-->Neighbor searching<!--EIdx--></h3>
<dl>
<dt><h4>nstlist: (10) [steps]</h4></dt>
<dd>Frequency to update the <!--Idx-->neighbor list<!--EIdx--> (and
the long-range forces, when using twin-range cut-off's). When this is 0,
the neighbor list is made only once.</dd>

<dt><h4>ns_type:</h4></dt>
<dd><dl compact>
<dt><b>grid</b></dt>
<dd>Make a grid in the box and only check atoms in neighboring grid
cells when constructing a new neighbor list every <b>nstlist</b> steps.
In large systems grid search is much faster than simple search.</dd>
<dt><b>simple</b></dt>
<dd>Check every atom in the box when constructing a new neighbor list
every <b>nstlist</b> steps.</dd>
</dl></dd>

<dt><h4>pbc:</h4></dt>
<dd><dl compact>
<dt><b>xyz</b></dt>
<dd>Use periodic boundary conditions in all directions.</dd>
<dt><b>no</b></dt>
<dd>Use no periodic boundary conditions, ignore the box.
To simulate without cut-offs, set all cut-offs to 0 and <b>nstlist</b>=0.</dd>
</dl></dd>

<dt><h4>rlist: (1) [nm]</h4></dt>
<dd>cut-off distance for the short-range neighbor list</dd>
</dl>


<A NAME="el"><br>
<hr>
<h3><!--Idx-->Electrostatics<!--EIdx--></h3>
<dl>
<dt><h4>coulombtype:</h4></dt>
<dd><dl compact>

<dt><b>Cut-off</b></dt>
<dd>Twin range cut-off's with neighborlist cut-off <b>rlist</b> and 
Coulomb cut-off <b>rcoulomb</b>,
where <b>rcoulomb</b> &gt= <b>rlist</b>.

<dt><b>Ewald</b></dt>
<dd>Classical <!--Idx-->Ewald sum<!--EIdx--> electrostatics.
The real-space cut-off <b>rcoulomb</b> should be equal to <b>rlist</b>.
Use e.g. <b>rlist</b>=0.9, <b>rcoulomb</b>=0.9. The highest magnitude of
wave vectors used in reciprocal space is controlled by <b>fourierspacing</b>.
The relative accuracy of direct/reciprocal space
is controlled by <b>ewald_rtol</b>.
<br>
NOTE: Ewald scales as O(N<sup>3/2</sup>)
and is thus extremely slow for large systems. It is included mainly for
reference - in most cases PME will perform much better.</dd>

<dt><b><!--Idx-->PME<!--EIdx--></b></dt>
<dd>Fast Particle-Mesh Ewald electrostatics. Direct space is similar
to the Ewald sum, while the reciprocal part is performed with
FFTs. Grid dimensions are controlled with <b>fourierspacing</b> and the
interpolation order with <b>pme_order</b>. With a grid spacing of 0.1
nm and cubic interpolation the electrostatic forces have an accuracy
of 2-3e-4. Since the error from the vdw-cutoff is larger than this you
might try 0.15 nm. When running in parallel the interpolation
parallelizes better than the FFT, so try decreasing grid dimensions
while increasing interpolation.</dd>

<dt><b><!--Idx-->PPPM<!--EIdx--></b></dt>
<dd>Particle-Particle Particle-Mesh algorithm for long range
electrostatic interactions.
Use for example <b>rlist</b><tt>=0.9</tt>, <b>rcoulomb</b><tt>=0.9</TT>.
The grid dimensions are controlled by <b>fourierspacing</b>.
Reasonable grid spacing for PPPM is 0.05-0.1 nm.
See <tt>Shift</tt> for the details of the particle-particle potential.
<br>
NOTE: the pressure in incorrect when using PPPM.</dd>

<dt><b><!--Idx-->Reaction-Field<!--EIdx--></b></dt>
<dd>Reaction field with Coulomb cut-off <b>rcoulomb</b>,
where <b>rcoulomb</b> &gt= <b>rlist</b>.
The dielectric constant beyond the cut-off is <b>epsilon_rf</b>.
The dielectric constant can be set to infinity by setting <b>epsilon_rf</b>=0.</dd>

<dt><b>Generalized-Reaction-Field</b></dt>
<dd>Generalized reaction field with Coulomb cut-off <b>rcoulomb</b>,
where <b>rcoulomb</b> &gt= <b>rlist</b>.
The dielectric constant beyond the cut-off is <b>epsilon_rf</b>.
The ionic strength is computed from the number of charged 
(i.e. with non zero charge) <!--Idx-->charge group<!--EIdx-->s.
The temperature for the GRF potential is set with 
<b><A HREF="#tc">ref_t</A></b> [K].</dd>

<dt><b>Reaction-Field-nec</b></dt>
<dd>The same as <b>Reaction-Field</b>, but implemented as in
GROMACS versions before 3.3. No reaction-field correction is applied
to excluded atom pairs and self pairs.
The 1-4 interactions are calculated using a reaction-field.
The missing correction due to the excluded pairs that do not have a 1-4
interaction is up to a few percent of the total electrostatic
energy and causes a minor difference in the forces and the pressure.</dd>

<dt><b>Shift</b></dt>
<dd>The Coulomb
potential is decreased over the whole range and the forces decay smoothly
to zero between <b>rcoulomb_switch</b> and <b>rcoulomb</b>.
The neighbor search cut-off <b>rlist</b> should be 0.1 to 0.3 nm larger than
<b>rcoulomb</b> to accommodate for the size of charge groups and diffusion
between neighbor list updates.</dd>

<dt><b>Encad-Shift</b></dt>
<dd>The Coulomb
potential is decreased over the whole range, using the definition
from the Encad simulation package.</dd>

<dt><b>Switch</b></dt>
<dd>The Coulomb
potential is normal out to <b>rcoulomb_switch</b>, after which it is switched
off to reach zero at <b>rcoulomb</b>. Both the potential and force functions
are continuously smooth, but be aware that all switch functions will give rise
to a bulge (increase) in the force (since we are switching the potential).
The neighbor search cut-off <b>rlist</b> should be 0.1 to 0.3 nm larger than
<b>rcoulomb</b> to accommodate for the size of charge groups and diffusion
between neighbor list updates.</dd>

<dt><b>User</b></dt> 
<dd><a name="user"></a><tt>mdrun</tt> will now expect to find a file
<tt>table.xvg</tt> with user-defined potential functions for
repulsion, dispersion and Coulomb.  This file should contain 7
columns: the <tt>x</tt> value, <tt>f(x)</tt>,
<tt>f<sup>(2)</sup>(x)</tt>, <tt>g(x)</tt>,
<tt>g<sup>(2)</sup>(x)</tt>, <tt>h(x)</tt>,
<tt>h<sup>(2)</sup>(x)</tt>, where <tt>f<sup>(2)</sup>(x)</tt>
denotes the <tt>2<sup>nd</sup></tt> derivative of function
<tt>f(x)</tt> with respect to <tt>x</tt>.  f(x) is the Coulomb
function, g(x) the dispersion function and h(x) the repulsion function.
The <tt>x</tt> values should run from 0 to the largest cut-off distance
+ <b>table-extension</b> and should be uniformly spaced.
The optimal spacing, which is used for non-user tables,
is <tt>0.002</tt> [nm] when you run in single precision
or <tt>0.0005</tt> [nm] when you run in double precision.
The function value at <tt>x=0</tt> is not important. More information is
in the printed manual.</dd>

<dt><b>PME-User</b></dt>
<dd>
A combination of PME and user tables (see above).
The PME mesh contribution is subtracted from the user table by <tt>mdrun</tt>.
Because of this subtraction the user tables should contain
about 10 decimal places.
</dd>

</dl></dd>

<A NAME="el2">
<dt><h4>rcoulomb_switch: (0) [nm]</h4></dt>
<dd>where to start switching the Coulomb potential</dd>

<dt><h4>rcoulomb: (1) [nm]</h4></dt>
<dd>distance for the Coulomb <!--Idx-->cut-off<!--EIdx--></dd>

<dt><h4>epsilon_r: (1)</h4></dt>
<dd>The relative <!--Idx-->dielectric constant<!--EIdx-->.
A value of 0 means infinity.</dd>

<dt><h4>epsilon_rf: (1)</h4></dt>
<dd>The relative dielectric constant of the reaction field.
This is only used with reaction-field electrostatics.
A value of 0 means infinity.</dd>
</dl>

<A NAME="vdw">
<hr>
<h3>VdW</h3>
<dl>
<dt><h4>vdwtype:</h4></dt>
<dd><dl compact>
<dt><b>Cut-off</b></dt>
<dd>Twin range cut-off's with neighbor list cut-off <b>rlist</b> and 
VdW cut-off <b>rvdw</b>,
where <b>rvdw</b> <tt>&gt=</tt> <b>rlist</b>.</dd>
<dt><b>Shift</b></dt>
<dd>The LJ (not Buckingham) potential is decreased over the whole
range and the forces decay smoothly to zero between <b>rvdw_switch</b>
and <b>rvdw</b>.  The neighbor search cut-off <b>rlist</b> should be
0.1 to 0.3 nm larger than <b>rvdw</b> to accommodate for the size of
charge groups and diffusion between neighbor list
updates.</dd>

<dt><b>Switch</b></dt>
<dd>The LJ (not Buckingham)
potential is normal out to <b>rvdw_switch</b>, after which it is switched
off to reach zero at <b>rvdw</b>. Both the potential and force functions
are continuously smooth, but be aware that all switch functions will give rise
to a bulge (increase) in the force (since we are switching the potential).
The neighbor search cut-off <b>rlist</b> should be 0.1 to 0.3 nm larger than
<b>rvdw</b> to accommodate for the size of charge groups and diffusion
between neighbor list updates.</dd>

<dt><b>Encad-Shift</b></dt>
<dd>The LJ (not Buckingham)
potential is decreased over the whole range, using the definition
from the Encad simulation package.</dd>

<dt><b>User</b></dt>
<dd><a href="#user">See above</a>
The function value at <tt>x=0</tt> is not important. When you want to
use LJ correction, make sure that <b>rvdw</b> corresponds to the
cut-off in the user-defined function.</dd>
</dl></dd>

<dt><h4>rvdw_switch: (0) [nm]</h4></dt>
<dd>where to start switching the LJ potential</dd>

<dt><h4>rvdw: (1) [nm]</h4></dt>
<dd>distance for the LJ or Buckingham <!--Idx-->cut-off<!--EIdx--></dd>

<dt><h4>DispCorr:</h4></dt>
<dd><dl compact></dd>
<dt><b>no</b></dt>
<dd>don't apply any correction</dd>
<dt><b>EnerPres</b></dt>
<dd>apply long range <!--Idx-->dispersion correction<!--EIdx-->s for Energy
and Pressure</dd>
<dt><b>Ener</b></dt>
<dd>apply long range dispersion corrections for Energy
only</dd>
</dl>
</dl>

<A NAME="table">
<hr>
<h3>Tables</h3>
<dl>
<dt><h4>table-extension: (1) [nm]</h4></dt>
<dd>Extension of the non-bonded potential lookup tables beyond the largest cut-off distance.
The value should be large enough to account for charge group sizes
and the diffusion between neighbor-list updates.
This value also specifies the length of the lookup tables for
the 1-4 interactions, which are always tabulated irrespective of the use of
tables for the non-bonded interactions. </dd>

<dt><h4>energygrp_table:</h4></dt>
<dd>When user tables are used for electrostatics and/or VdW,
here one can give pairs of energy groups for which seperate
user tables should be used.
The two energy groups will be appended to the table file name,
in order of their definition in <b>energygrps</b>, seperated by underscores.
For example, if <tt>energygrps = Na Cl Sol</tt>
and <tt>energygrp_table = Na Na Na Cl</tt>, <tt>mdrun</tt> will read
<tt>table_Na_Na.xvg</tt> and <tt>table_Na_Cl.xvg</tt> in addition
to the normal <tt>table.xvg</tt> which will be used for all other
energy group pairs.
</dd>
</dl>

<A NAME="ewald">
<hr>
<h3>Ewald</h3>
<dl>
<dt><h4>fourierspacing: (0.12) [nm]</h4></dt>
<dd>The maximum grid spacing for the FFT grid when using PPPM or PME.
For ordinary Ewald the spacing times the box dimensions determines the
highest magnitude to use in each direction. In all cases
each direction can be overridden by entering a non-zero value for
<b>fourier_n*</b>. </dd>

<dt><h4>fourier_nx (0) ; fourier_ny (0) ; fourier_nz: (0)</h4></dt>
<dd>Highest magnitude of wave vectors in reciprocal space when using Ewald.</dd>
<dd>Grid size when using PPPM or PME. These values override
<b>fourierspacing</b> per direction. The best choice is powers of
2, 3, 5 and 7. Avoid large primes.</dd>

<dt><h4>pme_order (4)</h4></dt>
<dd>Interpolation order for PME. 4 equals cubic interpolation. You might try
6/8/10 when running in parallel and simultaneously decrease grid dimension.</dd>

<dt><h4>ewald_rtol (1e-5)</h4></dt>
<dd>The relative strength of the Ewald-shifted direct potential at the cutoff
is given by <b>ewald_rtol</b>. Decreasing this will give a more accurate
direct sum, but then you need more wave vectors for the reciprocal sum.</dd>

<dt><h4>ewald_geometry: (3d)</h4></dt>
<dd>The geometry to use for Ewald summations. <b>3d</b> means the sum is performed
in all three dimensions. If your system has a slab geometry in the x-y plane you can 
try to increase box z dimension and use the <b>3dc</b> geometry. The reciprocal sum
is still performed in 3d, but a force and potential correction applied in the z 
dimension to produce a pseudo-2d summation. In the future there might also be a true
<b>2d</b> option, but this is not working yet.</dd>


<dt><h4>epsilon_surface: (0)</h4></dt>
<dd>This controls the dipole correction to the Ewald summation in 3d. The
default value of zero means it is turned off. Turn it on by setting it to the value 
of the relative permittivity of the imaginary surface around your infinite system. Be
careful - you shouldn't use this if you have free mobile charges in your system. 
This value does not affect the slab 3DC variant of the long range corrections.</dd>


<dt><h4>optimize_fft:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>Don't calculate the optimal FFT plan for the grid at startup.</dd>
<dt><b>yes</b></dt>
<dd>Calculate the optimal FFT plan for the grid at startup. This saves a
few percent for long simulations, but takes a couple of minutes
at start.</dd>
</dl></dd>

</dl>

<A NAME="tc"><br>
<hr>
<h3><!--Idx-->Temperature coupling<!--EIdx--></h3>

<dl>
<dt><h4>tcoupl:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>No temperature coupling.</dd>
<dt><b>berendsen</b></dt>
<dd>Temperature coupling with a Berendsen-thermostat to a bath with
temperature <b>ref_t</b> [K], with time constant <b>tau_t</b> [ps].
Several groups can be coupled separately, these are specified in the
<b>tc_grps</b> field separated by spaces.</dd>
<dt><b>nose-hoover</b></dt>
<dd>Temperature coupling with a by using a Nose-Hoover extended
ensemble. The reference temperature and coupling groups are selected
as above, but in this case <b>tau_t</b> [ps] controls the period
of the temperature fluctuations at equilibrium, which is slightly
different from a relaxation time.</dd>
</dl></dd>

<dt><h4>tc_grps:</h4></dt>
<dd>groups to couple separately to temperature bath</dd>
<dt><h4>tau_t: [ps]</h4></dt>
<dd>time constant for coupling (one for each group in tc_grps),
0 means no temperature coupling</dd>
<dt><h4>ref_t: [K]</h4></dt>
<dd>reference temperature for coupling (one for each group in tc_grps)</dd>
</dl>

<A NAME="pc"><br>
<hr>
<h3><!--Idx-->Pressure coupling<!--EIdx--></h3>

<dl>
<dt><h4>pcoupl:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>No pressure coupling. This means a fixed box size.</dd>
<dt><b>berendsen</b></dt>
<dd>Exponential relaxation pressure coupling with time constant
<b>tau_p</b> [ps]. The box is scaled every timestep. It has been
argued that this does not yield a correct thermodynamic ensemble,
but it is the most efficient way to scale a box at the beginning
of a run.</dd>
<dt><b>Parrinello-Rahman</b></dt>
<dd>Extended-ensemble pressure coupling where the box vectors
are subject to an equation of motion. The equation of motion for
the atoms is coupled to this. No instantaneous scaling takes place.
As for Nose-Hoover temperature coupling the time constant <b>tau_p</b>
[ps] is the period of pressure fluctuations at equilibrium. This is
probably a better method when you want to apply pressure scaling
during data collection, but beware that you can get very large
oscillations if you are starting from a different pressure.</dd>
</dl></dd>
</dl>

<dl>
<dt><h4>pcoupltype:</h4></dt>
<dd><dl compact>
<dt><b>isotropic</b></dt>
<dd>Isotropic pressure coupling with time constant <b>tau_p</b> [ps].
The compressibility and reference pressure are set with
<b>compressibility</b> [bar<sup>-1</sup>] and <b>ref_p</b> [bar], one
value is needed.</dd>
<dt><b>semiisotropic</b></dt>
<dd>Pressure coupling which is isotropic in the x and y direction,
but different in the z direction.
This can be useful for membrane simulations.
2 values are needed for x/y and z directions respectively.</dd>
<dt><b>anisotropic</b></dt>
<dd>Idem, but 6 values are needed for xx, yy, zz, xy/yx, xz/zx and yz/zy
components respectively.
When the off-diagonal compressibilities are set to zero,
a rectangular box will stay rectangular.
Beware that anisotropic scaling can lead to extreme deformation
of the simulation box.</dd>
<dt><b>surface-tension</b></dt>
<dd>Surface tension coupling for surfaces parallel to the xy-plane.
Uses normal pressure coupling for the z-direction, while the surface tension
is coupled to the x/y dimensions of the box.
The first <b>ref_p</b> value is the reference surface tension times
the number of surfaces [bar nm], 
the second value is the reference z-pressure [bar].
The two <b>compressibility</b> [bar<sup>-1</sup>] values are the compressibility
in the x/y and z direction respectively.
The value for the z-compressibility should be reasonably accurate since it
influences the convergence of the surface-tension, it can also be set to zero
to have a box with constant height.</dd>
</dl></dd>

<dt><h4>tau_p: (1) [ps]</h4></dt>
<dd>time constant for coupling</dd>
<dt><h4>compressibility: [bar<sup>-1</sup>]</h4></dt>
<dd>compressibility (NOTE: this is now really in bar<sup>-1</sup>)
For water at 1 atm and 300 K the compressibility is 4.5e-5 [bar<sup>-1</sup>].</dd>
<dt><h4>ref_p: [bar]</h4></dt>
<dd>reference pressure for coupling</dd>

</dl>

<A NAME="sa"><br>
<hr>
<h3><!--Idx-->Simulated annealing<!--EIdx--></h3>

Simulated annealing is controlled separately for each temperature group in GROMACS. The reference temperature is a piecewise linear function, but you can use an arbitrary number of points for each group, and choose either a single sequence or a periodic behaviour for each group. The actual annealing is performed by dynamically changing the reference temperature used in the thermostat algorithm selected, so remember that the system will usually not instantaneously reach the reference temperature!
<dl>
<dt><h4>annealing:</h4></dt>
<dd>Type of annealing for each temperature group</dd>
<dd><dl compact></dd>
<dt><b>no</b></dt>
<dd>No simulated annealing - just couple to reference temperature value.</dd>
<dt><b>single</b></dt>
<dd>A single sequence of annealing points. If your simulation is longer than the time of the last point, the temperature will be coupled to this constant value after the annealing sequence has reached the last time point.</dd>
<dt><b>periodic</b></dt>
<dd>The annealing will start over at the first reference point once the last reference time is reached. This is repeated until the simulation ends. 
</dd>
</dl>

<dt><h4>annealing_npoints:</h4></dt>
<dd>A list with the number of annealing reference/control points used for 
each temperature group. Use 0 for groups that are not annealed. The number of entries should equal the number of temperature groups.</dd>

<dt><h4>annealing_time:</h4></dt>
<dd>List of times at the annealing reference/control points for each group. If you are using periodic annealing, the times will be used modulo the last value, i.e. if the values are 0, 5, 10, and 15, the coupling will restart at the 0ps value after 15ps, 30ps, 45ps, etc. The number of entries should equal the sum of the numbers given in annealing_npoints.</dd>

<dt><h4>annealing_temp:</h4></dt>
<dd>List of temperatures at the annealing reference/control points for each group. The number of entries should equal the sum of the numbers given in annealing_npoints.</dd>
<br>
Confused? OK, let's use an example. Assume you have two temperature groups, set the group selections to <tt>annealing = single periodic</tt>, the number of points of each group to <tt>annealing_npoints = 3 4</tt>, the times to <tt>annealing_time = 0 3 6 0 2 4 6</tt> and finally temperatures to <tt>annealing_temp = 298 280 270 298 320 320 298</tt>.
The first group will be coupled to 298K at 0ps, but the reference temperature will drop linearly to reach 280K at 3ps, and then linearly between 280K and 270K from 3ps to 6ps. After this is stays constant, at 270K. The second group is coupled to 298K at 0ps, it increases linearly to 320K at 2ps, where it stays constant until 4ps. Between 4ps and 6ps it decreases to 298K, and then it starts over with the same pattern again, i.e. rising linearly from 298K to 320K between 6ps and 8ps. Check the summary printed by grompp if you are unsure!
</dl>

<A NAME="vel"><br>
<hr>
<h3>Velocity generation</h3>

<dl>
<dt><h4>gen_vel:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd> Do not generate velocities at startup. The velocities are set to zero
when there are no velocities in the input structure file.</dd>
<dt><b>yes</b></dt>
<dd>Generate velocities according to a Maxwell distribution at
temperature <b>gen_temp</b> [K], with random seed <b>gen_seed</b>. 
This is only meaningful with integrator <b><A HREF="#run">md</A></b>.</dd>
</dl></dd>
<dt><h4>gen_temp: (300) [K]</h4></dt>
<dd>temperature for Maxwell distribution</dd>
<dt><h4>gen_seed: (173529) [integer]</h4></dt>
<dd>used to initialize random generator for random velocities,
when <b>gen_seed</b> is set to -1, the seed is calculated as
<tt>(time() + getpid()) % 1000000</tt></dd>
</dl>

<A NAME="bond"><br>
<hr>
<h3>Bonds</h3>

<dl>
<dt><h4><!--Idx-->constraints<!--EIdx-->:</h4></dt>
<dd><dl compact>
<dt><b>none</b></dt>
<dd>No constraints except for those defined explicitly in the topology,
i.e. bonds are represented by a harmonic (or other) potential
or a Morse potential (depending on the setting of <b>morse</b>)
and angles by a harmonic (or other) potential.
<dt><b>hbonds</b></dt>
<dd>Convert the bonds with H-atoms to constraints.</dd>
<dt><b>all-bonds</b></dt>
<dd>Convert all bonds to constraints.</dd>
<dt><b>h-angles</b></dt>
<dd>Convert all bonds and additionally the angles that involve H-atoms
to bond-constraints.</dd>
<dt><b>all-angles</b></dt>
<dd>Convert all bonds and angles to bond-constraints.</dd>
</dl>

<dt><h4>constraint_algorithm:</h4></dt>
<dd><dl compact>
<dt><b><!--Idx-->lincs<!--EIdx--></b></dt>
<dd>LINear Constraint Solver. The accuracy in set with
<b>lincs_order</b>, which sets the number of matrices in the expansion
for the matrix inversion, 4 is enough for a "normal" MD simulation, 8 is
needed for BD with large time-steps. After the matrix inversion correction
the algorithm does an iterative correction to compensate for lengthening
due to rotation. The number of such iterations can be controlled with
<b>lincs_iter</b>. The accuracy of the 
constraints is printed to the log file every <b>nstlog</b> steps.
If a bond rotates more than <b>lincs_warnangle</b> [degrees] in one step, 
a warning will be printed both to the log file and to <TT>stderr</TT>. 
Lincs should not be used with coupled angle constraints.</dd>
<dt><b><!--Idx-->shake<!--EIdx--></b></dt>
<dd>Shake is slower and less stable than Lincs, but does work with 
angle constraints. 
The relative tolerance is set with <b>shake_tol</b>, 0.0001 is a good value
for "normal" MD. </dd>
</dl></dd>
<dt><h4>unconstrained_start:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>apply constraints to the start configuration and reset shells</dd>
<dt><b>yes</b></dt>
<dd>do not apply constraints to the start configuration
and do not reset shells, useful for exact coninuation and reruns</dd>
</dl></dd>

<A NAME="bond2">
<dt><h4>shake_tol: (0.0001)</h4></dt>
<dd>relative tolerance for shake</dd>
<dt><h4>lincs_order: (4)</h4></dt>
<dd>Highest order in the expansion of the constraint coupling matrix.</dd>
<dt><h4>lincs_iter: (1)</h4></dt>
<dd>Number of iterations to correct for rotational lengthening in Lincs.
For normal runs a single step is sufficient, but for NVE
runs where you want to conserve energy accurately you might want to increase
it to 2, and for energy minimization with constraints it is sometimes necessary
to use 4 or even 8 (double precision) iteration steps.
<dt><h4>lincs_warnangle: </b>(30) [degrees]</h4></dt>
<dd>maximum angle that a bond can rotate before Lincs will complain</dd>

<dt><h4>morse:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>bonds are represented by a harmonic potential</dd>
<dt><b>yes</b></dt>
<dd>bonds are represented by a Morse potential</dd>
</dl></dd>
</dl>

<A NAME="egexcl"><br>
<hr>
<h3>Energy group exclusions</h3>
<dl>
<dt><h4>energygrp_excl: </h4></dt>
<dd>Pairs of energy groups for which all non-bonded interactions are
excluded. An example: if you have two energy groups <tt>Protein</tt>
and <tt>SOL</tt>, specifying
<br>
<tt>energygrp_excl&nbsp;=&nbsp;Protein&nbsp;Protein&nbsp;&nbsp;SOL&nbsp;SOL</tt>
<br>
would give only the non-bonded interactions between the protein and the
solvent. This is especially useful for speeding up energy calculations with
<tt>mdrun -rerun</tt> and for excluding interactions within frozen groups.</dd>
</dl>

<A NAME="nmr"><br>
<hr>
<h3><!--Idx-->NMR refinement<!--EIdx--></h3>
<dl>
<dt><h4>disre:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>no <!--Idx-->distance restraints<!--EIdx--> (ignore distance
restraint information in topology file)</dd>
<dt><b>simple</b></dt>
<dd>simple (per-molecule) distance restraints,
ensemble averaging can be performed with <tt>mdrun -multi</tt></dd>
<dt><b>ensemble</b></dt>
<dd>distance restraints over an ensemble of molecules in one simulation box,
should only be used for special cases, such as dimers</dd>
</dl></dd>
<dt><h4>disre_weighting:</h4></dt>
<dd><dl compact>
<dt><b>conservative</b></dt>
<dd>the forces are the derivative of the restraint potential,
this results in an r<sup>-7</sup> weighting of the atom pairs</dd>
<dt><b>equal</b></dt>
<dd>divide the restraint force equally over all atom pairs in the restraint</dd>
</dl></dd>
<dt><h4>disre_mixed:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>the violation used in the calculation of the restraint force is the
time averaged violation </dd>
<dt><b>yes</b></dt>
<dd>the violation used in the calculation of the restraint force is the
square root of the time averaged violation times the instantaneous violation </dd>
</dl></dd>

<dt><h4>disre_fc: (1000) [kJ mol<sup>-1</sup> nm<sup>-2</sup>]</h4></dt>
<dd>force constant for distance restraints, which is multiplied by a
(possibly) different factor for each restraint</dd>

<dt><h4>disre_tau: (0) [ps]</h4></dt>
<dd>time constant for distance restraints running average</dd>

<dt><h4>nstdisreout: (100) [steps]</h4></dt>
<dd>frequency to write the running time averaged and instantaneous distances
of all atom pairs involved in restraints to the energy file
(can make the energy file very large)</dd>

<A NAME="nmr2">
<dt><h4>orire:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>no <!--Idx-->orientation restraints<!--EIdx--> (ignore orientation
restraint information in topology file)</dd>
<dt><b>yes</b></dt>
<dd>use orientation restraints, ensemble averaging can be performed
with <tt>mdrun -multi</tt></dd>
</dl>
<dt><h4>orire_fc: (0) [kJ mol]</h4></dt>
<dd>force constant for orientation restraints, which is multiplied by a
(possibly) different factor for each restraint, can be set to zero to
obtain the orientations from a free simulation</dd>
<dt><h4>orire_tau: (0) [ps]</h4></dt>
<dd>time constant for orientation restraints running average</dd>
<dt><h4>orire_fitgrp: </h4></dt>
<dd>fit group for orientation restraining, for a protein backbone is a good
choice</dd>
<dt><h4>nstorireout: (100) [steps]</h4></dt>
<dd>frequency to write the running time averaged and instantaneous orientations
for all restraints and the molecular order tensor to the energy file
(can make the energy file very large)</dd>
</dl>

<A NAME="free"><br>
<hr>
<h3><!--Idx-->Free Energy Perturbation<!--EIdx--></h3>

<dl>
<dt><h4>free_energy:</h4></dt>
<dd><dl compact>
<dt><b>no</b></dt>
<dd>Only use topology A.</dd>
<dt><b>yes</b></dt>
<dd>Interpolate between topology A (lambda=0) to topology B (lambda=1)
and write the derivative of the Hamiltonian with respect to lambda to
the energy file and to <tt>dgdl.xvg</tt>.
The potentials, bond-lengths and angles are interpolated linearly as
described in the manual. When <b>sc_alpha</b> is larger than zero, soft-core
potentials are used for the LJ and Coulomb interactions.</dd>
</dl></dd>
<dt><h4>init_lambda: (0)</h4></dt>
<dd>starting value for lambda</dd>
<dt><h4>delta_lambda: (0)</h4></dt>
<dd>increment per time step for lambda</dd>
<dt><h4>sc_alpha: (0)</h4></dt>
<dd>the soft-core parameter, a value of 0 results in linear interpolation of
the LJ and Coulomb interactions</dd>
<dt><h4>sc_power: (0)</h4></dt>
<dd>the power for lambda in the soft-core function,
only the values 1 and 2 are supported</dd>
<dt><h4>sc_sigma: (0.3) [nm]</h4></dt>
<dd>the soft-core sigma for particles which have a C6 or C12 parameter equal
to zero</dd>
</dl>


<A NAME="neq"><br>
<hr>
<h3><!--Idx-->Non-equilibrium MD<!--EIdx--></h3>

<dl>
<dt><h4>acc_grps: </h4></dt>
<dd>groups for constant acceleration (e.g.: <tt>Protein Sol</tt>)
all atoms in groups Protein and Sol will experience constant acceleration
as specified in the <b>accelerate</b> line</dd>
<dt><h4>accelerate: (0) [nm ps<sup>-2</sup>]</h4></dt>
<dd>acceleration for <b>acc_grps</b>; x, y and z for each group
(e.g. <tt>0.1 0.0 0.0 -0.1 0.0 0.0</tt> means that first group has constant 
acceleration of 0.1 nm ps<sup>-2</sup> in X direction, second group the 
opposite).</dd>
<dt><h4>freezegrps: </h4></dt>
<dd>Groups that are to be frozen (i.e. their X, Y, and/or Z position will
not be updated; e.g. <tt>Lipid SOL</tt>). <b>freezedim</b> specifies for
which dimension the freezing applies.
To avoid spurious contibrutions to the virial and pressure due to large
forces between completely frozen atoms you need to use
<A HREF="#egexcl">energy group exclusions</A>, this also saves computing time.
Note that frozen coordinates are not subject to pressure scaling.</dd>
<dt><h4>freezedim: </h4></dt>
<dd>dimensions for which groups in <b>freezegrps</b> should be frozen, 
specify <tt>Y</tt> or <tt>N</tt> for X, Y and Z and for each group
(e.g. <tt>Y Y N N N N</tt> means that particles in the first group 
can move only in Z direction. The particles in the second group can 
move in any direction).</dd>
<dt><h4>cos_acceleration: (0) [nm ps<sup>-2</sup>]</h4></dt>
<dd>the amplitude of the acceleration profile for calculating the
<!--Idx-->viscosity<!--EIdx-->.
The acceleration is in the X-direction and the magnitude is 
<b>cos_acceleration</b> cos(2 pi z/boxheight).
Two terms are added to the energy file:
the amplitude of the velocity profile and 1/viscosity.</dd>
<dt><h4><!--Idx-->deform<!--EIdx-->: (0 0 0 0 0 0) [nm ps<sup>-1</sup>]</h4></dt>
<dd>The velocities of deformation for the box elements:
a(x) b(y) c(z) b(x) c(x) c(y). Each step the box elements
for which <b>deform</b> is non-zero are calculated as:
box(ts)+(t-ts)*deform, off-diagonal elements are corrected
for periodicity. The coordinates are transformed accordingly.
Frozen degrees of freedom are (purposely) also transformed.
The time ts is set to t at the first step and at steps at which
x and v are written to trajectory to ensure exact restarts.
Deformation can be used together with semiisotropic or anisotropic
pressure coupling when the appropriate compressibilities are set to zero.
The diagonal elements can be used to <!--Idx-->strain<!--EIdx--> a solid.
The off-diagonal elements can be used to <!--Idx-->shear<!--EIdx--> a solid
or a liquid.</dd>
</dl>

<A NAME="ef"><br>
<hr>
<h3><!--Idx-->Electric field<!--EIdx-->s</h3>

<dl>
<dt><h4>E_x ; E_y ; E_z:</h4></dt>
<dd>If you want to use an electric field in a direction, enter 3 numbers
after the appropriate E_*, the first number: the number of cosines,
only 1 is implemented (with frequency 0) so enter 1,
the second number: the strength of the electric field in
<b>V nm<sup>-1</sup></b>,
the third number: the phase of the cosine, you can enter any number here
since a cosine of frequency zero has no phase.</dd>
<dt><h4>E_xt;  E_yt;  E_zt: </h4></dt>
<dd>not implemented yet</dd>
</dl>
<br>

<hr>
<A NAME="qmmm"><br>
<h3><!--Idx-->Mixed quantum/classical molecular dynamics<!--EIdx--></h3>

<dl>
<dt></dt><h4>QMMM:</h4>
<dd><dl compact="compact">
<dt><b>no</b></dt>
<dd>No QM/MM.</dd>
<dt><b>yes</b></dt>
<dd>Do a QM/MM simulation. Several groups can be described at
different QM levels separately. These are specified in
the <b>QMMM-grps</b> field separated by spaces. The level of <i>ab
initio</i> theory at which the groups are described is speficied
by <b>QMmethod</b> and <b>QMbasis</b> Fields. Describing the
groups at different levels of theory is only possible with the ONIOM
QM/MM scheme, specified by <b>QMMMscheme</b>.</dd>
</dl></dd>

<dt></dt><h4>QMMM-grps:</h4>
<dd>groups to be descibed at the QM level</dd>

<dt></dt><h4>QMMMscheme:</h4>
<dd><dl compact="compact">
<dt><b>normal</b></dt>
<dd>normal QM/MM. There can only be one <b>QMMM-grps</b> that is modelled
at the <b>QMmethod</b> and <b>QMbasis</b> level of <i>ab initio</i>
theory. The rest of the system is described at the MM level. The QM
and MM subsystems interact as follows: MM point charges are included
in the QM one-electron hamiltonian and all Lennard-Jones interactions
are described at the MM level.</dd>
<dt><b>ONIOM</b></dt>
<dd>The interaction between the subsystem is described using the ONIOM
method by Morokuma and co-workers. There can be more than one <b>QMMM-grps</b> each modeled at a different level of QM theory
(<b>QMmethod</b> and <b>QMbasis</b>).
</dd></dl></dd>

<dt></dt><h4>QMmethod: (RHF)</h4>
<dd>Method used to compute the energy and gradients on the QM
atoms. Available methods are AM1, PM3, RHF, UHF, DFT, B3LYP, MP2,
CASSCF, and MMVB. For CASSCF, the number of electrons and orbitals
included in the active space is specified by <b>CASelectrons</b>
and <b>CASorbitals</b>. </dd>

<dt></dt><h4>QMbasis: (STO-3G)</h4>
<dd>Basisset used to expand the electronic wavefuntion. Only gaussian
bassisets are currently available, <i>i.e.</i> STO-3G, 3-21G, 3-21G*,
3-21+G*, 6-21G, 6-31G, 6-31G*, 6-31+G*, and 6-311G.</dd>

<dt></dt><h4>QMcharge: (0) [integer]</h4>
<dd>The total charge in <i>e</i> of the <b>QMMM-grps</b>. In case
there are more than one <b>QMMM-grps</b>, the total charge of each
ONIOM layer needs to be specified separately.</dd>

<dt></dt><h4>QMmult: (1) [integer]</h4>
<dd>The multiplicity of the <b>QMMM-grps</b>. In case there are more
than one <b>QMMM-grps</b>, the multiplicity of each ONIOM layer needs
to be specified separately.</dd>

<dt></dt><h4>CASorbitals: (0) [integer]</h4>
<dd>The number of orbitals to be included in the active space when
doing a CASSCF computation.</dd>

<dt></dt><h4>CASelectrons: (0) [integer]</h4>
<dd>The number of electrons to be included in the active space when
doing a CASSCF computation.</dd>

<dt></dt><h4>SH:</h4>
<dd><dl compact="compact">
<dt><b>no</b></dt>
<dd>No surface hopping. The system is always in the electronic
ground-state.</dd>
<dt><b>yes</b></dt>
<dd>Do a QM/MM MD simulation on the excited state-potential energy
surface and enforce a <i>diabatic</i> hop to the ground-state when the
system hits the conical intersection hyperline in the course the
simulation. This option only works in combination with the CASSCF
method.</dd>
</dl>
</dl>


<A NAME="user"><br>
<hr>
<h3>User defined thingies</h3>

<dl>
<dt><h4>user1_grps; user2_grps: </h4></dt>
<dt><h4>userint1 (0); userint2 (0); userint3 (0); userint4 (0)</h4></dt>
<dt><h4>userreal1 (0); userreal2 (0); userreal3 (0); userreal4 (0)</h4></dt>
<dd>These you can use if you modify code. You can pass integers and
reals to your subroutine. Check the inputrec definition in
<tt>src/include/types/inputrec.h</tt></dd>

</dl>

<A NAME="idx"><br>
<hr>
<h3>Index</h3>

<P>

<multicol cols=4> 
<A HREF="#neq">acc_grps</A><br>
<A HREF="#neq">accelerate</A><br>
<A HREF="#sa">annealing</A><br>
<A HREF="#sa">annealing_npoints</A><br>
<A HREF="#sa">annealing_time</A><br>
<A HREF="#sa">annealing_temp</A><br>
<A HREF="#ld">bd_fric</A><br>
<A HREF="#vdw">bDispCorr</A><br>
<A HREF="#run">comm_mode</A><br>
<A HREF="#run">comm_grps</A><br>
<A HREF="#pc">compressibility</A><br>
<A HREF="#bond">constraint_algorithm</A><br>
<A HREF="#bond">constraints</A><br>
<A HREF="#neq">cos_acceleration</A><br>
<A HREF="#el">coulombtype</A><br>
<A HREF="#pp">cpp</A><br>
<A HREF="#pp">define</A><br>
<A HREF="#neq">deform</A><br>
<A HREF="#free">delta_lambda</A><br>
<A HREF="#nmr">disre</A><br>
<A HREF="#nmr">disre_weighting</A><br>
<A HREF="#nmr">disre_mixed</A><br>
<A HREF="#nmr">disre_fc</A><br>
<A HREF="#nmr">disre_tau</A><br>
<A HREF="#run">dt</A><br>
<A HREF="#em">emstep</A><br>
<A HREF="#em">emtol</A><br>
<A HREF="#egexcl">energygrp_excl</A><br>
<A HREF="#table">energygrp_table</A><br>
<A HREF="#out">energygrps</A><br>
<A HREF="#el2">epsilon_r</A><br>
<A HREF="#el2">epsilon_rf</A><br>
<A HREF="#ewald">ewald_rtol</A><br>
<A HREF="#ewald">ewald_geometry</A><br>
<A HREF="#ewald">epsilon_surface</A><br>
<A HREF="#ef">E_x</A><br>
<A HREF="#ef">E_xt</A><br>
<A HREF="#ef">E_y</A><br>
<A HREF="#ef">E_yt</A><br>
<A HREF="#ef">E_z</A><br>
<A HREF="#ef">E_zt </A><br>
<A HREF="#xmdrun">fcstep</A><br>
<A HREF="#ewald">fourier_nx</A><br>
<A HREF="#ewald">fourier_ny</A><br>
<A HREF="#ewald">fourier_nz</A><br>
<A HREF="#ewald">fourierspacing</A><br>
<A HREF="#free">free_energy</A><br>
<A HREF="#neq">freezedim </A><br>
<A HREF="#neq">freezegrps</A><br>
<A HREF="#vel">gen_seed</A><br>
<A HREF="#vel">gen_temp</A><br>
<A HREF="#vel">gen_vel</A><br>
<A HREF="#pp">include</A><br>
<A HREF="#free">init_lambda</A><br>
<A HREF="#run">init_step</A><br>
<A HREF="#run">integrator</A><br>
<A HREF="#ld">ld_seed</A><br>
<A HREF="#bond2">lincs_order</A><br>
<A HREF="#bond2">lincs_iter</A><br>
<A HREF="#bond2">lincs_warnangle</A><br>
<A HREF="#bond2">morse</A><br>
<A HREF="#em">nbfgscorr</A><br>
<A HREF="#xmdrun">niter</A><br>
<A HREF="#em">nstcgsteep</A><br>
<A HREF="#run">nstcomm</A><br>
<A HREF="#nmr">nstdisreout</A><br>
<A HREF="#out">nstenergy</A><br>
<A HREF="#run">nsteps</A><br>
<A HREF="#out">nstfout</A><br>
<A HREF="#nl">nstlist</A><br>
<A HREF="#out">nstlog</A><br>
<A HREF="#out">nstvout</A><br>
<A HREF="#out">nstxout</A><br>
<A HREF="#out">nstxtcout</A><br>
<A HREF="#nl">ns_type</A><br>
<A HREF="#ewald">optimize_fft</A><br>
<A HREF="#nmr2">orire</A><br>
<A HREF="#nmr2">orire_fc</A><br>
<A HREF="#nmr2">orire_tau</A><br>
<A HREF="#nmr2">orire_fitgrp</A><br>
<A HREF="#nmr2">nstorireout</A><br>
<A HREF="#nl">pbc</A><br>
<A HREF="#pc">pcoupl</A><br>
<A HREF="#pc">pcoupltype</A><br>
<A HREF="#ewald">pme_order</A><br>
<A HREF="#pc">ref_p</A><br>
<A HREF="#tc">ref_t</A><br>
<A HREF="#nl">rlist</A><br>
<A HREF="#el2">rcoulomb_switch</A><br>
<A HREF="#el2">rcoulomb</A><br>
<A HREF="#vdw">rvdw_switch</A><br>
<A HREF="#vdw">rvdw</A><br>
<A HREF="#free">sc_alpha</A><br>
<A HREF="#free">sc_power</A><br>
<A HREF="#free">sc_sigma</A><br>
<A HREF="#bond2">shake_tol</A><br>
<A HREF="#table">table-extension</A><br>
<A HREF="#pc">tau_p</A><br>
<A HREF="#tc">tau_t</A><br>
<A HREF="#tc">tc_grps</A><br>
<A HREF="#tc">tcoupl</A><br>
<A HREF="#run">tinit</A><br>
<A HREF="#pp">title</A><br>
<A HREF="#bond">unconstrained_start</A><br>
<A HREF="#user">user1_grps</A><br>
<A HREF="#user">user2_grps</A><br>
<A HREF="#user">userint1</A><br>
<A HREF="#user">userint2</A><br>
<A HREF="#user">userint3</A><br>
<A HREF="#user">userint4</A><br>
<A HREF="#user">userreal1</A><br>
<A HREF="#user">userreal2</A><br>
<A HREF="#user">userreal3</A><br>
<A HREF="#user">userreal4</A><br>
<A HREF="#el">vdwtype</A><br>
<A HREF="#pp">warnings</A><br>
<A HREF="#out">xtc_grps</A><br>
<A HREF="#out">xtc_precision</A><br>
<A HREF="#sa">zero_temp_time</A><br>
</multicol>

<hr>
<div ALIGN=RIGHT>
<font size="-1"><a href="http://www.gromacs.org">http://www.gromacs.org</a></font><br>

</div>
</BODY>
</HTML>

