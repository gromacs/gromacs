%
% This file is part of the GROMACS molecular simulation package.
%
% Copyright (c) 2013,2014,2015, by the GROMACS development team, led by
% Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,
% and including many others, as listed in the AUTHORS file in the
% top-level source directory and at http://www.gromacs.org.
%
% GROMACS is free software; you can redistribute it and/or
% modify it under the terms of the GNU Lesser General Public License
% as published by the Free Software Foundation; either version 2.1
% of the License, or (at your option) any later version.
%
% GROMACS is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% Lesser General Public License for more details.
%
% You should have received a copy of the GNU Lesser General Public
% License along with GROMACS; if not, see
% http://www.gnu.org/licenses, or write to the Free Software Foundation,
% Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.
%
% If you want to redistribute modifications to GROMACS, please
% consider that scientific software is very special. Version
% control is crucial - bugs must be traceable. We will be happy to
% consider code for inclusion in the official distribution, but
% derived work must not be called official GROMACS. Details are found
% in the README & COPYING files - if they are missing, get the
% official version at http://www.gromacs.org.
%
% To help us fund GROMACS development, we humbly ask that you cite
% the research papers on the package. Check out http://www.gromacs.org.

\chapter{Analysis}
\label{ch:analysis}
In this chapter different ways of analyzing your trajectory are described. 
The names of the corresponding analysis programs are given. 
Specific information on the in- and output of these programs can be found 
in the online manual at {\wwwpage}.
The output files are often produced as finished Grace/Xmgr graphs.

First, in \secref{usinggroups}, the group concept in analysis is explained. 
\ssecref{selections} explains a newer concept of dynamic selections,
which is currently supported by a few tools.
Then, the different analysis tools are presented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Groups in Analysis

\section{Using Groups}
\label{sec:usinggroups}\index{groups}
{\tt gmx make_ndx, gmx mk_angndx, gmx select}\\
In \chref{algorithms}, it was explained how {\em groups of
atoms} can be used in {\tt mdrun} (see~\secref{groupconcept}).
In most analysis programs, groups
of atoms must also be chosen. Most programs can generate several default
index groups, but groups can always be read from an index file. Let's
consider the example of a simulation of a binary mixture of components A and B. When
we want to calculate the radial distribution function (RDF)
$g_{AB}(r)$ of A with respect to B, we have to calculate:
\beq
4\pi r^2 g_{AB}(r)      ~=~     V~\sum_{i \in A}^{N_A} \sum_{j \in B}^{N_B} P(r)
\eeq
where $V$ is the volume and $P(r)$ is the probability of finding a B atom
at distance $r$ from an A atom.

By having the user define the {\em atom numbers} for groups A and B in
a simple file, we can calculate this $g_{AB}$ in the most general way, without
having to make any assumptions in the RDF program about the type of 
particles. 

Groups can therefore consist of a series of {\em atom numbers}, but in
some cases also of {\em molecule numbers}.  It is also possible to
specify a series of angles by {\em triples} of {\em atom numbers},
dihedrals by {\em quadruples} of {\em atom numbers} and bonds or
vectors (in a molecule) by {\em pairs} of {\em atom numbers}. When
appropriate the type of index file will be specified for the following
analysis programs.  To help creating such \swapindex{index}{file}s ({\tt
index.ndx}), there are a couple of programs to generate them, using
either your input configuration or the topology.  To generate an
index file consisting of a series of {\em atom numbers} (as in the
example of $g_{AB}$), use {\tt \normindex{gmx make_ndx}} or
{\tt \normindex{gmx select}}.  To generate an index file
with angles or dihedrals, use {\tt \normindex{gmx mk_angndx}}.
Of course you can also
make them by hand. The general format is presented here:

\begin{verbatim}
[ Oxygen ]
   1       4       7

[ Hydrogen ]
   2       3       5       6
   8       9
\end{verbatim}

First, the group name is written between square brackets. The following
atom numbers may be spread out over as many lines as you like. The
atom numbering starts at 1.

\swapindexquiet{choosing}{groups}%
Each tool that can use groups will offer the available alternatives
for the user to choose. That choice can be made with the number of the
group, or its name. In fact, the first few letters of the group
name will suffice if that will distinguish the group from all others.
There are ways to use Unix shell features to choose group names
on the command line, rather than interactively. Consult {\wwwpage}
for suggestions.

\subsection{Default Groups}
\label{subsec:defaultgroups}
When no index file is supplied to analysis tools or {\tt grompp},
a number of \swapindex{default}{groups} are generated to choose from:
\begin{description}
\item[{\tt System}]\mbox{}\\
        all atoms in the system
\item[{\tt Protein}]\mbox{}\\
        all protein atoms
\item[{\tt Protein-H}]\mbox{}\\
        protein atoms excluding hydrogens
\item[{\tt C-alpha}]\mbox{}\\
        C$_{\alpha}$ atoms
\item[{\tt Backbone}]\mbox{}\\
        protein backbone atoms; N, C$_{\alpha}$ and C
\item[{\tt MainChain}]\mbox{}\\
        protein main chain atoms: N, C$_{\alpha}$, C and O, including
        oxygens in C-terminus
\item[{\tt MainChain+Cb}]\mbox{}\\
        protein main chain atoms including C$_{\beta}$
\item[{\tt MainChain+H}]\mbox{}\\
        protein main chain atoms including backbone amide hydrogens and
        hydrogens on the N-terminus
\item[{\tt SideChain}]\mbox{}\\
        protein side chain atoms; that is all atoms except N,
        C$_{\alpha}$, C, O, backbone amide hydrogens, oxygens in
        C-terminus and hydrogens on the N-terminus
\item[{\tt SideChain-H}]\mbox{}\\
        protein side chain atoms excluding all hydrogens
%\ifthenelse{\equal{\gmxlite}{1}}{}{
\item[{\tt Prot-Masses}]\mbox{}\\
        protein atoms excluding dummy masses (as used in virtual site
        constructions of NH$_3$ groups and tryptophan side-chains),
        see also \secref{vsitetop}; this group is only included when
        it differs from the ``{\tt Protein}'' group
%} % Brace matches ifthenelse test for gmxlite
\item[{\tt Non-Protein}]\mbox{}\\
        all non-protein atoms
\item[{\tt DNA}]\mbox{}\\
        all DNA atoms
\item[{\tt RNA}]\mbox{}\\
        all RNA atoms
\item[{\tt Water}]\mbox{}\\
        water molecules (names like {\tt SOL}, {\tt WAT}, {\tt HOH}, etc.)  See
        {\tt \normindex{residuetypes.dat}} for a full listing
\item[{\tt non-Water}]\mbox{}\\
        anything not covered by the {\tt Water} group
\item[{\tt Ion}]\mbox{}\\
        any name matching an Ion entry in {\tt \normindex{residuetypes.dat}}
\item[{\tt Water_and_Ions}]\mbox{}\\
        combination of the {\tt Water} and {\tt Ions} groups 
\item[{\tt molecule_name}]\mbox{}\\
        for all residues/molecules which are not recognized as protein,
        DNA, or RNA; one group per residue/molecule name is generated
\item[{\tt Other}]\mbox{}\\
        all atoms which are neither protein, DNA, nor RNA.
\end{description}
Empty groups will not be generated.
Most of the groups only contain protein atoms.
An atom is considered a protein atom if its residue name is listed
in the {\tt \normindex{residuetypes.dat}} file and is listed as a
``Protein'' entry.  The process for determinding DNA, RNA, etc. is
analogous. If you need to modify these classifications, then you
can copy the file from the library directory into your working
directory and edit the local copy.

\subsection{Selections}
\label{subsec:selections}
{\tt \normindex{gmx select}}\\
Currently, a few analysis tools support an extended concept of {\em
(dynamic) \normindex{selections}}.  There are three main differences to
traditional index groups:
\begin{itemize}
  \item The selections are specified as text instead of reading fixed
    atom indices from a file, using a syntax similar to VMD.  The text
    can be entered interactively, provided on the command line, or from
    a file.
  \item The selections are not restricted to atoms, but can also specify
    that the analysis is to be performed on, e.g., center-of-mass
    positions of a group of atoms.
    Some tools may not support selections that do not evaluate to single
    atoms, e.g., if they require information that is available only for
    single atoms, like atom names or types.
  \item The selections can be dynamic, i.e., evaluate to different atoms
    for different trajectory frames.  This allows analyzing only a
    subset of the system that satisfies some geometric criteria.
\end{itemize}
As an example of a simple selection,
{\tt resname ABC and within 2 of resname DEF}
selects all atoms in residues named ABC that are within 2\,nm of any
atom in a residue named DEF.

Tools that accept selections can also use traditional index files
similarly to older tools: it is possible to give an {\tt .ndx} file to
the tool, and directly select a group from the index file as a
selection, either by group number or by group name.  The index groups
can also be used as a part of a more complicated selection.

To get started, you can run {\tt gmx select} with a single structure,
and use the interactive prompt to try out different selections.
The tool provides, among others, output options {\tt -on} and
{\tt -ofpdb} to write out the selected atoms to an index file and to a
{\tt .pdb} file, respectively.  This does not allow testing selections
that evaluate to center-of-mass positions, but other selections can be
tested and the result examined.

The detailed syntax and the individual keywords that can be used in
selections can be accessed by typing {\tt help} in the interactive
prompt of any selection-enabled tool, as well as with
{\tt gmx help selections}.  The help is divided into subtopics that can
be accessed with, e.g., {\tt help syntax} / {\tt gmx help selections
syntax}.  Some individual selection keywords have extended help as well,
which can be accessed with, e.g., {\tt help keywords within}.

The interactive prompt does not currently provide much editing
capabilities.  If you need them, you can run the program under
{\tt rlwrap}.

For tools that do not yet support the selection syntax, you can use
{\tt gmx select -on} to generate static index groups to pass to the
tool.  However, this only allows for a small subset (only the first
bullet from the above list) of the flexibility that fully
selection-aware tools offer.

It is also possible to write your own analysis
tools to take advantage of the flexibility of these selections: see the
{\tt template.cpp} file in the {\tt share/gromacs/template} directory of
your installation for an example.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Looking at your trajectory

\section{Looking at your trajectory}
\label{sec:lookwhostalking}
\begin{figure}
\centerline{
{\includegraphics[width=8cm,angle=90]{plots/ngmxdump}}}
\caption{The window of {\tt gmx view} showing a box of water.}
\label{fig:ngmxdump}
\end{figure}
{\tt gmx view}\\
Before analyzing your trajectory it is often informative to look at
your trajectory first. {\gromacs} comes with a simple trajectory
viewer {\tt \normindex{gmx view}}; the advantage with this one is that it does not
require OpenGL, which usually isn't present on {\eg} supercomputers.
It is also possible to generate a
hard-copy in Encapsulated Postscript format (see
\figref{ngmxdump}). If you want a faster and more fancy viewer
 there are several programs
that can read the {\gromacs} trajectory formats -- have a look at our
homepage ({\wwwpage}) for updated links. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% General properties

\section{General properties}
\label{sec:genprop}
{\tt gmx energy, gmx traj}\\
To analyze some or all {\em energies} and other properties, such as
{\em total pressure}, {\em pressure tensor}, {\em density}, {\em
box-volume} and {\em box-sizes}, use the program {\tt \normindex{gmx energy}}.  A
choice can be made from a list a set of energies, like potential,
kinetic or total energy, or individual contributions, like
Lennard-Jones or dihedral energies.

The {\em center-of-mass velocity}, defined as
\beq
{\bf v}_{com} = {1 \over M} \sum_{i=1}^N m_i {\bf v}_i
\eeq
with $M = \sum_{i=1}^N m_i$ the total mass of the system, can be
monitored in time by the program {\tt \normindex{gmx traj} -com -ov}. It is however
recommended to remove the center-of-mass velocity every step (see
\chref{algorithms})!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Radial distribution functions 

\section{Radial distribution functions}
\label{sec:rdf}
{\tt gmx rdf}\\
The {\em radial distribution function} (RDF) or pair correlation
function $g_{AB}(r)$ between particles of type $A$ and $B$ is defined
in the following way:
\newcommand{\dfrac}[2]{\displaystyle \frac{#1}{#2}}
\beq
\begin{array}{rcl}
g_{AB}(r)&=&    \dfrac{\langle \rho_B(r) \rangle}{\langle\rho_B\rangle_{local}}         \\
         &=&    \dfrac{1}{\langle\rho_B\rangle_{local}}\dfrac{1}{N_A}
                \sum_{i \in A}^{N_A} \sum_{j \in B}^{N_B} 
                \dfrac{\delta( r_{ij} - r )}{4 \pi r^2}         \\
\end{array}
\eeq
with $\langle\rho_B(r)\rangle$ the particle density of type $B$ at a distance $r$
around particles $A$, and $\langle\rho_B\rangle_{local}$ the particle density of
type $B$ averaged over all spheres around particles $A$ with radius
$r_{max}$ (see \figref{rdfex}C).

\begin{figure}
\centerline{
{\includegraphics[width=7cm,angle=270]{plots/rdf}}}
\caption[Definition of slices in {\tt gmx rdf}.]{Definition of slices
in {\tt gmx rdf}: A. $g_{AB}(r)$. B. $g_{AB}(r,\theta)$. The slices are
colored gray. C. Normalization $\langle\rho_B\rangle_{local}$. D. Normalization
$\langle\rho_B\rangle_{local,\:\theta }$. Normalization volumes are colored gray.}
\label{fig:rdfex}
\end{figure}

Usually the value of $r_{max}$ is half of the box length.  The
averaging is also performed in time.  In practice the analysis program
{\tt \normindex{gmx rdf}} divides the system into spherical slices (from $r$ to
$r+dr$, see \figref{rdfex}A) and makes a histogram in stead of
the $\delta$-function. An example of the RDF of oxygen-oxygen in
SPC water~\cite{Berendsen81} is given in \figref{rdf}.

\begin{figure}
\centerline{
{\includegraphics[width=8cm]{plots/rdfO-O}}}
\caption{$g_{OO}(r)$ for Oxygen-Oxygen of SPC-water.}
\label{fig:rdf}
\end{figure}

% TODO: This functionality isn't there...
With {\tt gmx rdf} it is also possible to calculate an angle dependent rdf
$g_{AB}(r,\theta)$, where the angle $\theta$ is defined with respect to a 
certain laboratory axis ${\bf e}$, see \figref{rdfex}B.
\bea 
g_{AB}(r,\theta) &=& {1 \over \langle\rho_B\rangle_{local,\:\theta }} {1 \over N_A} \sum_{i \in A}^{N_A} \sum_{j \in B}^{N_B} {\delta( r_{ij} - r ) \delta(\theta_{ij} -\theta) \over 2 \pi r^2 sin(\theta)}\\
cos(\theta_{ij}) &=& {{\bf r}_{ij} \cdot {\bf e} \over \|r_{ij}\| \;\| e\| }
\eea
This $g_{AB}(r,\theta)$ is useful for analyzing anisotropic systems. 
{\bf Note} that in this case the normalization $\langle\rho_B\rangle_{local,\:\theta}$ is 
the average density in all angle slices from $\theta$ to $\theta + d\theta$ 
up to $r_{max}$, so angle dependent, see \figref{rdfex}D.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Correlation functions 
%\ifthenelse{\equal{\gmxlite}{1}}{}{

\section{Correlation functions}
\label{sec:corr}

\subsection{Theory of correlation functions}
The theory of correlation functions is well established~\cite{Allen87}.
We describe here the implementation of the various 
\normindex{correlation} function flavors in the {\gromacs} code.
The definition of the autocorrelation function\index{autocorrelation function} 
(ACF)
$C_f(t)$ for a property $f(t)$ is:
\beq
C_f(t)  ~=~     \left\langle f(\xi) f(\xi+t)\right\rangle_{\xi}
\label{eqn:corr}
\eeq
where the notation on the right hand side indicates averaging over $\xi$, {\ie} over
time origins.
It is also possible to compute cross-correlation function from two properties
$f(t)$ and $g(t)$:
\beq
C_{fg}(t) ~=~   \left\langle f(\xi) g(\xi+t)\right\rangle_{\xi}
\eeq
however, in {\gromacs} there is no standard mechanism to do this
({\bf note:} you can use the {\tt \normindex{xmgr}} program to compute cross correlations).
The integral of the correlation function over time is the 
correlation time $\tau_f$:
\beq
\tau_f  ~=~     \int_0^{\infty} C_f(t) {\rm d} t
\label{eqn:corrtime}
\eeq

In practice, correlation functions are calculated based on data points with
discrete time intervals {$\Delta$t}, so that the ACF from an MD simulation is:
\beq
C_f(j\Delta t)  ~=~     \frac{1}{N-j}\sum_{i=0}^{N-1-j} f(i\Delta t) f((i+j)\Delta t)
\label{eqn:corrmd}
\eeq
where $N$ is the number of available time frames for the calculation.
The resulting ACF is
obviously only available at time points with the same interval {$\Delta$t}.
Since, for many applications, it is necessary to know the short time behavior
of the ACF ({\eg} the first 10 ps) this often means that we have to save the
data with intervals much shorter than the time scale of interest.
Another implication of \eqnref{corrmd} is that in principle we can not compute
all points of the ACF with the same accuracy, since we have $N-1$ data points
for $C_f(\Delta t)$ but only 1 for $C_f((N-1)\Delta t)$. However, if we decide to
compute only an ACF of length $M\Delta t$, where $M \leq N/2$ we can compute 
all points with the same statistical accuracy:
\beq
C_f(j\Delta t)  ~=~ \frac{1}{M}\sum_{i=0}^{N-1-M} f(i\Delta t)f((i+j)\Delta t)
\eeq
Here of course $j < M$.
$M$ is sometimes referred to as the \normindex{time lag} of the correlation function. 
When we decide to do this, we intentionally do not use all the available points
for very short time intervals ($j << M$), but it makes it easier to interpret
the results.
Another aspect that may not be neglected when computing
ACFs from simulation is that usually the time origins $\xi$ (\eqnref{corr})
are not statistically independent, which may introduce a bias in the results.
This can be tested using a block-averaging procedure, where only time origins
with a spacing at least the length of the time lag are included, {\eg} using 
$k$ time origins with spacing of $M\Delta t$ (where $kM \leq N$):
\beq
C_f(j\Delta t)  ~=~ \frac{1}{k}\sum_{i=0}^{k-1} f(iM\Delta t)f((iM+j)\Delta t)
\eeq
However, one
needs very long simulations to get good accuracy this way, because there are 
many fewer points that contribute to the ACF.

\subsection{Using FFT for computation of the ACF}
The computational cost for calculating an ACF according to \eqnref{corrmd}
is proportional to $N^2$, which is considerable. However, this can be improved
by using fast Fourier transforms to do the convolution~\cite{Allen87}.

\subsection{Special forms of the ACF}
There are some important varieties on the ACF, {\eg} the ACF of a vector \ve{p}:
\beq
C_{\ve{p}}(t) ~=~       \int_0^{\infty} P_n(\cos\angle\left(\ve{p}(\xi),\ve{p}(\xi+t)\right) {\rm d} \xi
\label{eqn:corrleg}
\eeq
where $P_n(x)$ is the $n^{th}$ order Legendre polynomial
\footnote{$P_0(x) = 1$, $P_1(x) = x$, $P_2(x) = (3x^2-1)/2$}.
Such correlation times 
can actually be obtained experimentally using {\eg} NMR or other relaxation 
experiments. {\gromacs} can compute correlations using 
the 1$^{st}$ and 2$^{nd}$ order Legendre polynomial (\eqnref{corrleg}).
This can also be used for rotational autocorrelation
({\tt \normindex{gmx rotacf}})
and dipole autocorrelation ({\tt \normindex{gmx dipoles}}).

In order to study torsion angle dynamics, we define a dihedral 
autocorrelation function as~\cite{Spoel97a}:
\beq
C(t)    ~=~     \left\langle \cos(\theta(\tau)-\theta(\tau+t))\right\rangle_{\tau}
\label{eqn:coenk}
\eeq
{\bf Note} that this is not a  product of two functions 
as is generally used for correlation
functions, but it may be rewritten as the sum of two products:
\beq
C(t)    ~=~     \left\langle\cos(\theta(\tau))\cos(\theta(\tau+t))\,+\,\sin(\theta(\tau))\sin(\theta(\tau+t))\right\rangle_{\tau}
\label{eqn:cot}
\eeq

\subsection{Some Applications}
The program {\tt \normindex{gmx velacc}} calculates the {\em velocity autocorrelation 
function}.
\beq
C_{\ve{v}} (\tau) ~=~ \langle {\ve{v}}_i(\tau) \cdot {\ve{v}}_i(0) \rangle_{i \in A}
\eeq
The self diffusion coefficient can be calculated using the Green-Kubo 
relation~\cite{Allen87}:
\beq
D_A ~=~ {1\over 3} \int_0^{\infty} \langle {\bf v}_i(t) \cdot {\bf v}_i(0) \rangle_{i \in A} \; dt
\eeq
which is just the integral of the velocity autocorrelation function.
There is a widely-held belief that the velocity ACF converges faster than the mean
square displacement (\secref{msd}), which can also be used for the computation of 
diffusion constants. However, Allen \& Tildesley~\cite{Allen87} 
warn us that the long-time 
contribution to the velocity ACF can not be ignored, so care must be taken.

Another important quantity is the dipole correlation time. The {\em dipole 
correlation function} for particles of type $A$ is calculated as follows by 
{\tt \normindex{gmx dipoles}}:
\beq
C_{\mu} (\tau) ~=~
\langle {\bf \mu}_i(\tau) \cdot {\bf \mu}_i(0) \rangle_{i \in A}
\eeq
with ${\bf \mu}_i = \sum_{j \in i} {\bf r}_j q_j$. The dipole correlation time 
can be computed using \eqnref{corrtime}.
For some applications see~\cite{Spoel98a}.

The \normindex{viscosity} of a liquid can be related to the correlation 
time of the Pressure tensor $\ve{P}$~\cite{PSmith93c,Balasubramanian96}.
{\tt \normindex{gmx energy}} can compute the viscosity,
but this is not very accurate~\cite{Hess2002a}, and 
actually the values do not converge.
%} % Brace matches ifthenelse test for gmxlite

\section{Curve fitting in \gromacs}
\subsection{Sum of exponential functions}
Sometimes it is useful to fit a curve to an analytical function, for
example in the case of autocorrelation functions with noisy
tails. {\gromacs} is not a general purpose curve-fitting tool however
and therefore {\gromacs} only supports a limited number of
functions. 
Table~\ref{tab:fitfn} lists the available options with the
corresponding command-line options. The underlying routines for
fitting use the Levenberg-Marquardt algorithm as implemented in the
{\tt lmfit} package~\cite{lmfit} (a bare-bones version of which is
included in {\gromacs} in which an option for error-weighted fitting
was implemented). 
\begin{table}[ht]
\centering
\caption{Overview of fitting functions supported in (most) analysis tools
  that compute autocorrelation functions. The ``Note'' column describes
  properties of the output parameters.}
\label{tab:fitfn}
\begin{tabular}{lcc}
\hline
Command & Functional form $f(t)$& Note\\
line option         &           & \\
\hline
exp        & $e^{-t/{a_0}}$ &\\
aexp      & $a_1e^{-t/{a_0}}$ &\\
exp_exp & $a_1e^{-t/{a_0}}+(1-a_1)e^{-t/{a_2}}$ & $a_2\ge a_0\ge 0$\\
exp5      & $a_1e^{-t/{a_0}}+a_3e^{-t/{a_2}}+a_4$ &$a_2\ge a_0\ge 0$\\
exp7     &
$a_1e^{-t/{a_0}}+a_3e^{-t/{a_2}}+a_5e^{-t/{a_4}}+a_6$&$a_4\ge a_2\ge
a_0 \ge0$\\
exp9    &
$a_1e^{-t/{a_0}}+a_3e^{-t/{a_2}}+a_5e^{-t/{a_4}}+a_7e^{-t/{a_6}}+a_8$&$a_6\ge
a_4\ge a_2\ge a_0\ge 0$\\
\hline
\end{tabular}
\end{table}

\subsection{Error estimation}
Under the hood {\gromacs} implements some more fitting functions,
namely a function to estimate the error in time-correlated data due to Hess~\cite{Hess2002a}:
\beq
\varepsilon^2(t) =
\alpha\tau_1\left(1+\frac{\tau_1}{t}\left(e^{-t/\tau_1}-1\right)\right)
      + (1-\alpha)\tau_2\left(1+\frac{\tau_2}{t}\left(e^{-t/\tau_2}-1\right)\right)
\eeq
where $\tau_1$ and
$\tau_2$ are time constants (with $\tau_2 \ge \tau_1$) and $\alpha$
usually is close to 1 (in the fitting procedure it is enforced that
$0\leq\alpha\leq 1$). This is used in {\tt gmx analyze} for error
estimation using
\beq
\lim_{t\rightarrow\infty}\varepsilon(t) = \sigma\sqrt{\frac{2(\alpha\tau_1+(1-\alpha)\tau_2)}{T}}
\eeq
where $\sigma$ is the standard deviation of the data set and $T$ is
the total simulation time~\cite{Hess2002a}.

\subsection{Interphase boundary demarcation}
In order to determine the position and width of an interface,
Steen-S{\ae}thre {\em et al.} fitted a density profile to the
following function
\beq
f(x) ~=~ \frac{a_0+a_1}{2} - \frac{a_0-a_1}{2}{\rm
  erf}\left(\frac{x-a_2}{a_3^2}\right)
\eeq
where $a_0$ and $a_1$ are densities of different phases, $x$ is the
coordinate normal to the interface, $a_2$ is the position of the
interface and $a_3$ is the width of the
interface~\cite{Steen-Saethre2014a}.
This is implemented in {\tt gmx densorder}.

\subsection{Transverse current autocorrelation function}
In order to establish the transverse current autocorrelation function
(useful for computing viscosity~\cite{Palmer1994a})
the following function is fitted:
\beq
f(x) ~=~ e^{-\nu}\left({\rm cosh}(\omega\nu)+\frac{{\rm
    sinh}(\omega\nu)}{\omega}\right)
\eeq
with $\nu = x/(2a_0)$ and $\omega = \sqrt{1-a_1}$.
This is implemented in {\tt gmx tcaf}.

\subsection{Viscosity estimation from pressure autocorrelation
  function}
The viscosity is a notoriously difficult property to extract from
simulations~\cite{Hess2002a,Wensink2003a}. It is {\em in principle}
possible to determine it by integrating the pressure autocorrelation
function~\cite{PSmith93c}, however this is often hampered by the noisy
tail of the ACF. A workaround to this is fitting the ACF to the
following function~\cite{Guo2002b}:
\beq
f(t)/f(0) = (1-C) {\rm cos}(\omega t) e^{-(t/\tau_f)^{\beta_f}} + C
e^{-(t/\tau_s)^{\beta_s}}
\eeq
where $\omega$ is the frequency of rapid pressure oscillations (mainly
due to bonded forces in molecular simulations), $\tau_f$ and $\beta_f$
are the time constant and exponent of fast relaxation in a
stretched-exponential approximation, $\tau_s$ and $\beta_s$ are constants
for slow relaxation and $C$ is the pre-factor that determines the
weight between fast and slow relaxation. After a fit, the integral of
the function $f(t)$ is used to compute the viscosity:
\beq
\eta = \frac{V}{k_B T}\int_0^{\infty} f(t) dt
\eeq
This equation has been
applied to computing the bulk and shear viscosity using different
elements from the pressure tensor~\cite{Fanourgakis2012a}.
This is implemented in {\tt gmx viscosity}.

\section{Mean Square Displacement}
\label{sec:msd}
{\tt gmx msd}\\
To determine the self diffusion coefficient\index{diffusion coefficient} $D_A$ 
of
particles of type $A$, one can use the \normindex{Einstein
relation}~\cite{Allen87}:
\beq 
\lim_{t \rightarrow \infty} \langle
\|{\bf r}_i(t) - {\bf r}_i(0)\|^2 \rangle_{i \in A} ~=~ 6 D_A t 
\eeq
This {\em mean square displacement} and $D_A$ are calculated by the
program {\tt \normindex{gmx msd}}. Normally an index file containing
atom numbers is used and the MSD is averaged over these atoms.  For
molecules consisting of more than one atom, ${\bf r}_i$ can be taken
as the center of mass positions of the molecules. In that case, you
should use an index file with molecule numbers. The results will be
nearly identical to averaging over atoms, however. The {\tt gmx msd}
program can
also be used for calculating diffusion in one or two dimensions. This
is useful for studying lateral diffusion on interfaces.

An example of the mean square displacement of SPC water is given in
\figref{msdwater}.

\begin{figure}
\centerline{
{\includegraphics[width=8cm]{plots/msdwater}}}
\caption{Mean Square Displacement of SPC-water.}
\label{fig:msdwater}
\end{figure}

%\ifthenelse{\equal{\gmxlite}{1}}{}{
% 
%%%%%%%%%%%%%%%%%%%%% Bonds, angles and dihedral %%%%%%%%%%%%%%%%%%%
% 
\section{Bonds/distances, angles and dihedrals}
\label{sec:bad}
{\tt gmx distance, gmx angle, gmx gangle}\\
To monitor specific {\em bonds} in your modules, or more generally
distances between points, the program
{\tt \normindex{gmx distance}} can calculate distances as a function of
time, as well as the distribution of the distance.
With a traditional index file, the groups should consist of pairs of
atom numbers, for example:
\begin{verbatim}
[ bonds_1 ]
 1     2
 3     4
 9    10

[ bonds_2 ]
12    13
\end{verbatim}
Selections are also supported, with first two positions defining the
first distance, second pair of positions defining the second distance
and so on.  You can calculate the distances between CA and CB atoms in
all your residues (assuming that every residue either has both atoms, or
neither) using a selection such as:
\begin{verbatim}
name CA CB
\end{verbatim}
The selections also allow more generic distances to be computed.
For example, to compute the distances between centers of mass of two
residues, you can use:
\begin{verbatim}
com of resname AAA plus com of resname BBB
\end{verbatim}

The program {\tt \normindex{gmx angle}} calculates the distribution of {\em angles} and
{\em dihedrals} in time. It also gives the average angle or dihedral. 
The index file consists of triplets or quadruples of atom numbers:

\begin{verbatim}
[ angles ]
 1     2     3
 2     3     4
 3     4     5

[ dihedrals ]
 1     2     3     4
 2     3     5     5
\end{verbatim}

For the dihedral angles you can use either the ``biochemical convention'' 
($\phi = 0 \equiv cis$) or ``polymer convention'' ($\phi = 0 \equiv trans$), 
see \figref{dih_def}.

\begin{figure}
\centerline{
{\includegraphics[width=3.5cm,angle=270]{plots/dih-def}}}
\caption[Dihedral conventions.]{Dihedral conventions: A. ``Biochemical
convention''. B. ``Polymer convention''.}
\label{fig:dih_def}
\end{figure}

The program {\tt \normindex{gmx gangle}} provides a selection-enabled
version to compute angles.  This tool can also compute angles and
dihedrals, but does not support all the options of {\tt gmx angle}, such
as autocorrelation or other time series analyses.
In addition, it supports angles between two vectors, a vector and a
plane, two planes (defined by 2 or 3 points, respectively), a
vector/plane and the $z$ axis, or a vector/plane and the normal of a
sphere (determined by a single position).
Also the angle between a vector/plane compared to its position in the
first frame is supported.
For planes, {\tt \normindex{gmx gangle}} uses the normal vector
perpendicular to the plane.
See \figref{sgangle}A, B, C) for the definitions.

\begin{figure}
\centerline{
{\includegraphics{plots/sgangle}}}
\caption[Angle options of {\tt gmx gangle}.]{Angle options of {\tt gmx gangle}:
A. Angle between two vectors.
B. Angle between two planes.
C. Angle between a vector and the $z$ axis.
D. Angle between a vector and the normal of a sphere.
Also other combinations are supported: planes and vectors can be used
interchangeably.}
\label{fig:sgangle}
\end{figure}
%} % Brace matches ifthenelse test for gmxlite

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Radius of gyration and distances

\section{Radius of gyration and distances}
\label{sec:rg}
{\tt gmx gyrate, gmx distance, gmx mindist, gmx mdmat, gmx pairdist, gmx xpm2ps}\\
To have a rough measure for the compactness of a structure, you can calculate 
the {\em radius of gyration} with the program {\tt \normindex{gmx gyrate}} as follows:
\beq
R_g ~=~ \left({\frac{\sum_i \|{\bf r}_i\|^2 m_i}{\sum_i m_i}}\right)^{\half}
\label{eqn:rg}
\eeq
where $m_i$ is the mass of atom $i$ and ${\bf r}_i$ the position of 
atom $i$ with respect to the center of mass of the molecule. It is especially 
useful to characterize polymer solutions and proteins. The program will also
provide the radius of gyration around the coordinate axis (or, optionally, principal axes)
by only summing the radii components orthogonal to each axis, for instance
\beq
R_{g,x} ~=~ \left({\frac{\sum_i \left( r_{i,y}^2 + r_{i,z}^2 \right) m_i}{\sum_i m_i}}\right)^{\half}
\label{eqn:rg}
\eeq

Sometimes it is interesting to plot the {\em distance} between two atoms,
or the {\em minimum} distance between two groups of atoms
({\eg}: protein side-chains in a salt bridge). 
To calculate these distances between certain groups there are several 
possibilities:
\begin{description}
\item[$\bullet$] 
The {\em distance between the geometrical centers} of two groups can be 
calculated with the program
%\ifthenelse{\equal{\gmxlite}{1}}{
{{\tt \normindex{gmx distance}}, as explained in \secref{bad}.}
\item[$\bullet$]
The {\em minimum distance} between two groups of atoms during time 
can be calculated with the program {\tt \normindex{gmx mindist}}. It also calculates the 
{\em number of contacts} between these groups 
within a certain radius $r_{max}$.
\item[$\bullet$]
{\tt \normindex{gmx pairdist}} is a selection-enabled version of
{\tt gmx mindist}.
\item[$\bullet$]
To monitor the {\em minimum distances between amino acid residues} 
within a (protein) molecule, you can use 
the program {\tt \normindex{gmx mdmat}}. This minimum distance between two residues
A$_i$ and A$_j$ is defined as the smallest distance between any pair of 
atoms (i $\in$ A$_i$, j $\in$ A$_j$).
The output is a symmetrical matrix of smallest distances 
between all residues.
To visualize this matrix, you can use a program such as {\tt xv}.
If you want to view the axes and legend or if you want to print
the matrix, you can convert it with 
{\tt xpm2ps} into a Postscript picture, see \figref{mdmat}.
\begin{figure}
\centerline{
\includegraphics[width=6.5cm]{plots/distm}}
\caption{A minimum distance matrix for a peptide~\protect\cite{Spoel96b}.}
\label{fig:mdmat}
\end{figure}

Plotting these matrices for different time-frames, one can analyze changes 
in the structure, and {\eg} forming of salt bridges.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Root mean square deviations 

\section{Root mean square deviations in structure}
\label{sec:rmsd}
{\tt gmx rms, gmx rmsdist}\\
The {\em root mean square deviation} ($RMSD$) of certain atoms in a molecule
with respect to a reference structure can be calculated with the program 
{\tt \normindex{gmx rms}} by least-square fitting the structure to the reference structure
($t_2 = 0$) and subsequently calculating the $RMSD$ (\eqnref{rmsd}).
\beq
RMSD(t_1,t_2) ~=~ \left[\frac{1}{M} \sum_{i=1}^N m_i \|{\bf r}_i(t_1)-{\bf r}_i(t_2)\|^2 \right]^{\frac{1}{2}}
\label{eqn:rmsd}
\eeq
where $M = \sum_{i=1}^N m_i$ and ${\bf r}_i(t)$ is the position of atom $i$ at time $t$.
{\bf Note} that fitting does not have to use the same atoms as the calculation
of the $RMSD$; {\eg} a protein is usually fitted on the backbone atoms
(N,C$_{\alpha}$,C), but the $RMSD$ can be computed of the backbone
or of the whole protein.

Instead of comparing the structures to the initial structure at time $t=0$ 
(so for example a crystal structure), one can also calculate \eqnref{rmsd} 
with a structure at time $t_2=t_1-\tau$.
This gives some insight in the mobility as a function of $\tau$.
A matrix can also be made with the $RMSD$ as a function of $t_1$ and $t_2$,
which gives a nice graphical interpretation of a trajectory.
If there are transitions in a trajectory, they will clearly show up in
such a matrix.

Alternatively the $RMSD$ can be computed using a fit-free method with the 
program {\tt \normindex{gmx rmsdist}}:
\beq
RMSD(t) ~=~     \left[\frac{1}{N^2}\sum_{i=1}^N \sum_{j=1}^N    \|{\bf r}_{ij}(t)-{\bf r}_{ij}(0)\|^2\right]^{\frac{1}{2}}
\label{eqn:rmsdff}
\eeq
where the {\em distance} {\bf r}$_{ij}$ between atoms at time $t$ 
is compared with the distance between the same atoms at time $0$.

%\ifthenelse{\equal{\gmxlite}{1}}{}{
\section{Covariance analysis\index{covariance analysis}}
\label{sec:covanal}
Covariance analysis, also called
\seeindex{principal component analysis}{covariance analysis}
or \seeindex{essential dynamics}{covariance analysis}
\cite{Amadei93}{,} can find correlated motions.
It uses the covariance matrix $C$ of the atomic coordinates:
\beq
C_{ij} = \left \langle 
M_{ii}^{\frac{1}{2}} (x_i - \langle x_i \rangle)
M_{jj}^{\frac{1}{2}}  (x_j - \langle x_j \rangle)
\right \rangle
\eeq
where $M$ is a diagonal matrix containing the masses of the atoms
(mass-weighted analysis) or the unit matrix (non-mass weighted analysis).
$C$ is a symmetric $3N \times 3N$ matrix, which can be diagonalized with
an orthonormal transformation matrix $R$:
\beq
R^T C R = \mbox{diag}(\lambda_1,\lambda_2,\ldots,\lambda_{3N})
~~~~\mbox{where}~~\lambda_1 \geq \lambda_2 \geq \ldots \geq \lambda_{3N}
\eeq
The columns of $R$ are the eigenvectors, also called principal or
essential modes.
$R$ defines a transformation to a new coordinate system. The trajectory
can be projected on the principal modes to give the principal components
$p_i(t)$:
\beq
{\bf p}(t) = R^T M^{\frac{1}{2}} ({\bf x}(t) - \langle {\bf x} \rangle)
\eeq
The eigenvalue $\lambda_i$ is the mean square fluctuation of principal
component $i$. The first few principal modes often describe 
collective, global motions in the system.
The trajectory can be filtered along one (or more) principal modes.
For one principal mode $i$ this goes as follows:
\beq
{\bf x}^f(t) =
\langle {\bf x} \rangle + M^{-\frac{1}{2}} R_{*i} \, p_i(t)
\eeq

When the analysis is performed on a macromolecule, one often wants to
remove the overall rotation and translation to look at the internal motion
only. This can be achieved by least square fitting to a reference structure.
Care has to be taken that the reference structure is representative for the
ensemble, since the choice of reference structure influences the covariance
matrix.

One should always check if the principal modes are well defined.
If the first principal component resembles a half cosine and
the second resembles a full cosine, you might be filtering noise (see below).
A good way to check the relevance of the first few principal
modes is to calculate the overlap of the sampling between
the first and second half of the simulation.
{\bf Note} that this can only be done when the same reference structure is
used for the two halves.

A good measure for the overlap has been defined in~\cite{Hess2002b}.
The elements of the covariance matrix are proportional to the square
of the displacement, so we need to take the square root of the matrix
to examine the extent of sampling. The square root can be
calculated from the eigenvalues $\lambda_i$ and the eigenvectors,
which are the columns of the rotation matrix $R$.
For a symmetric and diagonally-dominant matrix $A$ of size $3N \times 3N$
the square root can be calculated as:
\beq
A^\frac{1}{2} = 
R \, \mbox{diag}(\lambda_1^\frac{1}{2},\lambda_2^\frac{1}{2},\ldots,\lambda_{3N}^\frac{1}{2}) \, R^T
\eeq
It can be verified easily that the product of this matrix with itself gives
$A$.
Now we can define a difference $d$ between covariance matrices $A$ and $B$
as follows:
\begin{eqnarray}
d(A,B) & = & \sqrt{\mbox{tr}\left(\left(A^\frac{1}{2} - B^\frac{1}{2}\right)^2\right)
}
\\ & = &
\sqrt{\mbox{tr}\left(A + B - 2 A^\frac{1}{2} B^\frac{1}{2}\right)}
\\ & = &
\left( \sum_{i=1}^N \left( \lambda_i^A + \lambda_i^B \right)
- 2 \sum_{i=1}^N \sum_{j=1}^N \sqrt{\lambda_i^A \lambda_j^B}
\left(R_i^A \cdot R_j^B\right)^2 \right)^\frac{1}{2}
\end{eqnarray}
where tr is the trace of a matrix.
We can now define the overlap $s$ as:
\beq
s(A,B) = 1 - \frac{d(A,B)}{\sqrt{\mbox{tr}A + \mbox{tr} B}}
\eeq
The overlap is 1 if and only if matrices $A$ and $B$ are identical.
It is 0 when the sampled subspaces are completely orthogonal.

A commonly-used measure is the subspace overlap of the first few
eigenvectors of covariance matrices.
The overlap of the subspace spanned by $m$ orthonormal vectors 
${\bf w}_1,\ldots,{\bf w}_m$ with a reference subspace spanned by 
$n$ orthonormal vectors ${\bf v}_1,\ldots,{\bf v}_n$
can be quantified as follows:
\beq
\mbox{overlap}({\bf v},{\bf w}) =
\frac{1}{n} \sum_{i=1}^n \sum_{j=1}^m ({\bf v}_i \cdot {\bf w}_j)^2
\eeq
The overlap will increase with increasing $m$ and will be 1 when
set ${\bf v}$ is a subspace of set ${\bf w}$.
The disadvantage of this method is that it does not take the eigenvalues
into account. All eigenvectors are weighted equally, and when
degenerate subspaces are present (equal eigenvalues), the calculated overlap
will be too low.

Another useful check is the cosine content. It has been proven that the
the principal components of random diffusion are cosines with the number of
periods equal to half the principal component index~\cite{Hess2000,Hess2002b}.
The eigenvalues are proportional to the index to the power $-2$.
The cosine content is defined as:
\beq
\frac{2}{T}
\left( \int_0^T \cos\left(\frac{i \pi t}{T}\right) \, p_i(t) \mbox{d} t \right)^2
\left( \int_0^T p_i^2(t) \mbox{d} t \right)^{-1}
\eeq
When the cosine content of the first few principal components
is close to 1, the largest fluctuations are not connected with
the potential, but with random diffusion.

The covariance matrix is built and diagonalized by
{\tt \normindex{gmx covar}}.
The principal components and overlap (and many more things)
can be plotted and analyzed with {\tt \normindex{gmx anaeig}}.
The cosine content can be calculated with {\tt \normindex{gmx analyze}}.
%} % Brace matches ifthenelse test for gmxlite

%\ifthenelse{\equal{\gmxlite}{1}}{}{
\section{Dihedral principal component analysis}
{\tt gmx angle, gmx covar, gmx anaeig}\\
Principal component analysis can be performed in dihedral
space~\cite{Mu2005a} using {\gromacs}. You start by defining the
dihedral angles of interest in an index file, either using {\tt
 gmx mk_angndx} or otherwise. Then you use the {\tt gmx angle} program
with the {\tt -or} flag to produce a new {\tt .trr} file containing the cosine and
sine of each dihedral angle in two coordinates, respectively. That is,
in the {\tt .trr} file you will have a series of numbers corresponding to:
cos($\phi_1$), sin($\phi_1$), cos($\phi_2$), sin($\phi_2$), ...,
cos($\phi_n$), sin($\phi_n$), and the array is padded with zeros, if
necessary.  Then you can use this {\tt .trr} file as input for the {\tt
 gmx covar} program and perform principal component analysis as usual.
For this to work you will need to generate a reference file ({\tt .tpr}, 
{\tt .gro}, {\tt .pdb} etc.) containing the same number of ``atoms'' 
as the new {\tt .trr} file, that is for $n$ dihedrals you need 2$n$/3 atoms 
(rounded up if not an integer number). 
You should use the {\tt -nofit} option for {\tt
gmx covar} since the coordinates in the dummy reference file do not
correspond in any way to the information in the {\tt .trr} file. Analysis of
the results is done using {\tt gmx anaeig}.
%} % Brace matches ifthenelse test for gmxlite
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Hydrogen bonds

\section{Hydrogen bonds}
{\tt gmx hbond}\\
The program {\tt \normindex{gmx hbond}} analyzes the {\em hydrogen bonds} (H-bonds)
between all possible donors D and acceptors A. To determine if an
H-bond exists, a geometrical criterion is used, see also
\figref{hbond}:
\beq
\begin{array}{rclcl}
r       & \leq  & r_{HB}        & = & 0.35~\mbox{nm}    \\
\alpha  & \leq  & \alpha_{HB}   & = & 30^o              \\
\end{array}
\eeq

\begin{figure}
\centerline{\includegraphics[width=2.5cm,angle=270]{plots/hbond}}
\caption{Geometrical Hydrogen bond criterion.}
\label{fig:hbond}
\end{figure}

The value of $r_{HB} = 0.35$~nm corresponds to the first minimum of the RDF of 
SPC water (see also \figref{rdf}).

The program {\tt gmx hbond} analyzes all hydrogen bonds existing
between two groups of atoms (which must be either identical or
non-overlapping) or in specified donor-hydrogen-acceptor triplets, in
the following ways:

\begin{figure}
\centerline{
{\includegraphics[width=5cm,angle=270]{plots/hbond-insert}}}
\caption[Insertion of water into an H-bond.]{Insertion of water into
an H-bond. (1) Normal H-bond between two residues. (2) H-bonding
bridge via a water molecule.}
\label{fig:insert}
\end{figure}

\begin{itemize}
\item
Donor-Acceptor distance ($r$) distribution of all H-bonds
\item
Hydrogen-Donor-Acceptor angle ($\alpha$) distribution of all H-bonds 
\item
The total number of H-bonds in each time frame
\item
\newcommand{\nn}[1]{$n$-$n$+$#1$}
The number of H-bonds in time between residues, divided into groups
\nn{i} where $n$ and $n$+$i$ stand for residue numbers and $i$ goes
from 0 to 6. The group for $i=6$ also includes all H-bonds for
$i>6$. These groups include the \nn{3}, \nn{4} and \nn{5} H-bonds,
which provide a measure for the formation of $\alpha$-helices or
$\beta$-turns or strands.
\item
The lifetime of the H-bonds is calculated from the average over all
autocorrelation functions of the existence functions (either 0 or 1)
of all H-bonds:
\beq
C(\tau) ~=~ \langle s_i(t)~s_i (t + \tau) \rangle
\label{eqn:hbcorr}
\eeq
with $s_i(t) = \{0,1\}$ for H-bond $i$ at time $t$. The integral of
$C(\tau)$ gives a rough estimate of the average H-bond lifetime
$\tau_{HB}$:
\beq
\tau_{HB} ~=~ \int_{0}^{\infty} C(\tau) d\tau
\label{eqn:hblife}
\eeq
Both the integral and the complete autocorrelation function $C(\tau)$
will be output, so that more sophisticated analysis ({\eg}\@ using
multi-exponential fits) can be used to get better estimates for
$\tau_{HB}$. A more complete analysis is given in ref.~\cite{Spoel2006b};
one of the more fancy option is the Luzar and Chandler analysis
of hydrogen bond kinetics~\cite{Luzar96b,Luzar2000a}. 
\item
An H-bond existence map can be generated of dimensions {\em
\#~H-bonds}$\times${\em \#~frames}. The ordering is identical to the index 
file (see below), but reversed, meaning that the last triplet in the index
file corresponds to the first row of the existence map.
\item
Index groups are output containing the analyzed groups, all
donor-hydrogen atom pairs and acceptor atoms in these groups,
donor-hydrogen-acceptor triplets involved in hydrogen bonds between
the analyzed groups and all solvent atoms involved in insertion.

\end{itemize}

%\ifthenelse{\equal{\gmxlite}{1}}{}{
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Protein related items 

\section{Protein-related items}
{\tt gmx do_dssp, gmx rama, gmx wheel}\\
To analyze structural changes of a protein, you can calculate the radius of 
gyration or the minimum residue distances over time 
(see \secref{rg}), or calculate the RMSD (\secref{rmsd}).

You can also look at the changing of {\em secondary structure elements} 
during your run. For this, you can use the program {\tt \normindex{gmx do_dssp}}, which is 
an interface for the commercial program {\tt DSSP}~\cite{Kabsch83}. For 
further information, see the {\tt DSSP} manual. A typical output plot of 
{\tt gmx do_dssp} is given in \figref{dssp}.

\begin{figure}
\centerline{
\includegraphics[width=12cm]{plots/dssp}}
\caption{Analysis of the secondary structure elements of a peptide in time.}
\label{fig:dssp}
\end{figure}

One other important analysis of proteins is the so-called 
{\em Ramachandran plot}. 
This is the projection of the structure on the two dihedral angles $\phi$ and 
$\psi$ of the protein backbone, see \figref{phipsi}.

\begin{figure}
\centerline{
\includegraphics[width=5cm]{plots/phipsi}}
\caption{Definition of the dihedral angles $\phi$ and $\psi$ of the protein backbone.}
\label{fig:phipsi}
\end{figure}

To evaluate this Ramachandran plot you can use the program {\tt
\normindex{gmx rama}}.
A typical output is given in \figref{rama}.

\begin{figure}
\centerline{
{\includegraphics[width=8cm]{plots/rama}}}
\caption{Ramachandran plot of a small protein.}
\label{fig:rama}
\end{figure}

When studying $\alpha$-helices 
it is useful to have a {\em helical wheel} projection
of your peptide, to see whether a peptide is amphipathic. This can be done
using the {\tt \normindex{gmx wheel}} program. Two examples are
plotted in \figref{wheel}.

\begin{figure}
\centerline{\includegraphics[width=\htw]{plots/hpr-wheel}}
\caption{Helical wheel projection of the N-terminal helix of HPr.}
\label{fig:wheel}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Membrane Related Items

\section{Interface-related items}
{\tt gmx order, gmx density, gmx potential, gmx traj}\\
When simulating molecules with long carbon tails, it can be
interesting to calculate their average orientation. There are several
flavors of order parameters, most of which are related. The program
{\tt \normindex{gmx order}} can calculate order parameters using the equation:

\begin{equation}
S_{z} = \frac{3}{2}\langle {\cos^2{\theta_z}} \rangle - \frac{1}{2}
\label{eqn:Sgr}
\end{equation}
where $\theta_z$ is the angle between the $z$-axis of the simulation
box and the molecular axis under consideration. The latter is defined as the
vector from C$_{n-1}$ to C$_{n+1}$. The parameters $S_x$
and $S_y$ are defined in the same way. The brackets imply averaging over time
and molecules. Order parameters can vary between 1 (full order along
the interface normal) and $-1/2$ (full order perpendicular to the
normal), with a value of zero in the case of isotropic orientation.

The program can do two things for you. It can calculate the order
parameter for each CH$_2$ segment separately, for any of three axes,
or it can divide the box in slices and calculate the average value of
the order parameter per segment in one slice. The first method gives
an idea of the ordering of a molecule from head to tail, the second
method gives an idea of the ordering as function of the box length.

The electrostatic potential ($\psi$) across the interface can be
computed from a trajectory by evaluating the double integral of the
charge density ($\rho(z)$):
\beq
\psi(z) - \psi(-\infty) = - \int_{-\infty}^z dz' \int_{-\infty}^{z'} \rho(z'')dz''/ \epsilon_0 
\label{eqn:elpotgr}
\eeq
where the position $z=-\infty$ is far enough in the bulk phase such that
the field is zero.  With this method, it is possible to ``split'' the
total potential into separate contributions from lipid and water
molecules. The program {\tt \normindex{gmx potential}} divides the box in slices and
sums all charges of the atoms in each slice. It then integrates this
charge density to give the electric field, which is in turn integrated to
give the potential. Charge density, electric field, and potential are written
to {\tt xvgr} input files.

The program {\tt \normindex{gmx traj}} is a very simple analysis program. All it
does is print the coordinates, velocities, or forces of selected atoms.
It can also calculate the center of mass of one or more
molecules and print the coordinates of the center of mass to three
files. By itself, this is probably not a very useful analysis, but
having the coordinates of selected molecules or atoms can be very
handy for further analysis, not only in interfacial systems.

The program {\tt \normindex{gmx density}} calculates the mass density of
groups and gives a plot of the density against a box
axis. This is useful for looking at the distribution of groups or
atoms across the interface.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Chemical shifts

% \section{Chemical shifts}
% {\tt total, do_shift}\\
% You can compute the NMR chemical shifts of protons with the program
% {\tt \normindex{do_shift}}. This is just an {\gromacs} interface to
% the public domain program {\tt total}~\cite{Williamson93a}. For
% further information, read the article. Although there is limited
% support for this in {\gromacs}, users are encouraged to use the
% software provided by David Case's group at Scripps because it seems
% to be more up-to-date.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%} % Brace matches ifthenelse test for gmxlite

% LocalWords:  Xmgr ndx mk angndx rdf dihedrals grompp hydrogens MainChain Prot
% LocalWords:  oxygens SideChain tryptophan vsitetop aminoacids dat ngmx dr SPC
% LocalWords:  OO ACF fg xmgr corrmd ACFs kM iM FFT th NMR nd corrleg rotacf dt
% LocalWords:  velacc Kubo msd Tildesley corrtime msdwater sgangle cis dih xpm
% LocalWords:  mindist mdmat rms rmsdist rmsd jj diag eigenvectors covar anaeig
% LocalWords:  macromolecule trr tpr gro pdb nofit hbond rclcl HB multi Luzar
% LocalWords:  dssp rama xrama rg Ramachandran phipsi amphipathic HPr xvgr pvd
% LocalWords:  Scripps RDF online usinggroups mdrun groupconcept HOH
% LocalWords:  residuetypes determinding OpenGL traj ov rcl ij ps nm
% LocalWords:  autocorrelation interfacial pairdist
